<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
        pre { margin: 0; }
        .code-container { position: relative; }
        .copy-button { position: absolute; top: 12px; right: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 6px 10px; font-size: 12px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; cursor: pointer; color: #495057; transition: all 0.2s ease; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .copy-button:hover { background: #e9ecef; border-color: #adb5bd; color: #212529; }
        .copy-button.copied { background: #d4edda; border-color: #c3e6cb; color: #155724; }
        .copy-button:active { transform: translateY(1px); }
    </style>
</head>
<body>
<div class="code-container">
    <button class="copy-button" onclick="copyCode(this)" title="Copy code to clipboard">Copy</button>
    <pre><code class="csharp">using BruTile.Predefined;
using Mapsui.Layers;
using Mapsui.Layers.AnimatedLayers;
using Mapsui.Providers;
using Mapsui.Samples.Common.DataBuilders;
using Mapsui.Styles;
using Mapsui.Styles.Thematics;
using Mapsui.Tiling;
using Mapsui.Tiling.Extensions;
using Mapsui.Utilities;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Mapsui.Samples.Common.Maps.FeatureAnimations;

public sealed class AnimatedPointsSample : ISample, IDisposable
{
    private bool _disposed;
    readonly AnimatedPointsSampleProvider _animatedPointsSampleProvider = new();

    public string Name => "AnimatedPoints";
    public string Category => "FeatureAnimations";

    public Task<Map> CreateMapAsync()
    {
        var map = new Map();
        map.Layers.Add(OpenStreetMap.CreateTileLayer());
        map.Layers.Add(CreateAnimatedPointLayer(_animatedPointsSampleProvider));
        return Task.FromResult(map);
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _animatedPointsSampleProvider.Dispose();

        _disposed = true;
    }

    private static AnimatedPointLayer CreateAnimatedPointLayer(AnimatedPointsSampleProvider animatedPointsSampleProvider) => new(animatedPointsSampleProvider)
    {
        Name = "Animated Points",
        Style = CreatePointStyle()
    };

    private static ThemeStyle CreatePointStyle() => new(CreateSvgArrowStyle);

    private static ImageStyle CreateSvgArrowStyle(IFeature feature) => new()
    {
        Image = "embedded://Mapsui.Samples.Common.Images.arrow.svg",
        SymbolScale = 0.5,
        RelativeOffset = new RelativeOffset(0.0, 0.5),
        Opacity = 0.5f,
        SymbolRotation = (double)feature["rotation"]!
    };

    internal class AnimatedPointsSampleProvider : MemoryProvider, IDynamic, IDisposable
    {
        private readonly Timer _timer;
        private readonly Random _random = new(0);
        private List<PointFeature> _previousFeatures = new();
        private List<PointFeature> features = new();
        private static readonly MRect _extent = new GlobalSphericalMercator().Extent.ToMRect();

        public AnimatedPointsSampleProvider()
        {
            _timer = new Timer(_ =>
            {
                DataHasChanged();
                features = CreateNewFeatures(_random, _previousFeatures);
                _previousFeatures = MergeWithPreviousFeatures(_previousFeatures, features);
            }, this, 0, 1600);
        }

        public event EventHandler? DataChanged;

        public override Task<IEnumerable<IFeature>> GetFeaturesAsync(FetchInfo fetchInfo)
        {
            return Task.FromResult((IEnumerable<IFeature>)features);
        }

        private static List<PointFeature> CreateNewFeatures(Random random, List<PointFeature> previousFeatures)
        {
            var features = new List<PointFeature>();
            var points = RandomPointsBuilder.GenerateRandomPoints(_extent, 10, random).ToList();
            var count = 0;
            var randomItemToSkip = random.Next(points.Count);

            foreach (var point in points)
            {
                count++;
                if (count == randomItemToSkip)
                    continue; // Skip a random element to test robustness.

                var countAsString = count.ToString(CultureInfo.InvariantCulture);
                features.Add(new PointFeature(point)
                {
                    ["ID"] = countAsString,
                    ["rotation"] = (AngleOf(point, FindPreviousPosition(countAsString, previousFeatures), random) - 90 + 360) % 360
                });
            }

            return features;
        }

        private static MPoint? FindPreviousPosition(string countAsString, List<PointFeature> previousFeatures)
        {
            return previousFeatures.FirstOrDefault(f => f["ID"]?.ToString() == countAsString)?.Point;
        }

        public static double AngleOf(MPoint point1, MPoint? point2, Random random)
        {
            if (point2 == null)
                return random.Next(360);
            double result = Algorithms.RadiansToDegrees(Math.Atan2(point1.Y - point2.Y, point2.X - point1.X));
            return (result < 0) ? (360.0 + result) : result;
        }

        public void DataHasChanged()
        {
            OnDataChanged();
        }

        private void OnDataChanged()
        {
            DataChanged?.Invoke(this, new EventArgs());
        }

        public virtual void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                _timer.Dispose();
            }
        }
        private static List<PointFeature> MergeWithPreviousFeatures(List<PointFeature> previousFeatures, List<PointFeature> newFeatures)
        {
            // Some features are missing in the new list (to test robustness). We want to store the missing ones as well.
            return newFeatures
                .Concat(previousFeatures)
                .GroupBy(f => f["ID"])
                .Select(g => g.First())
                .ToList();
        }
    }

}
</code></pre>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/csharp.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        hljs.highlightAll();
        if (window.parent && window.parent !== window) {
            window.parent.postMessage('highlightjs-highlight', '*');
        }
    });
    function copyCode(button) {
        try {
            const codeElement = button.parentElement.querySelector('code');
            const codeText = codeElement.textContent || codeElement.innerText;
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(codeText).then(() => {
                    showCopySuccess(button);
                }).catch(() => {
                    fallbackCopy(codeText, button);
                });
            } else {
                fallbackCopy(codeText, button);
            }
        } catch (error) {
            console.error('Copy failed:', error);
            showCopyError(button);
        }
    }
    function fallbackCopy(text, button) {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showCopySuccess(button);
        } catch (error) {
            showCopyError(button);
        }
    }
    function showCopySuccess(button) {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.classList.add('copied');
        setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
        }, 2000);
    }
    function showCopyError(button) {
        const originalText = button.textContent;
        button.textContent = 'Failed';
        setTimeout(() => {
            button.textContent = originalText;
        }, 2000);
    }
</script>
</body>
</html>
