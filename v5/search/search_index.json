{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Mapsui is a .NET map component that supports all main .NET UI frameworks. </p> UI Framework NuGet MAUI Avalonia Uno Platform Blazor WPF WinUI Windows Forms Eto Forms .NET for Android .NET for iOS <p>Try the quick-start for your favorite framework below.</p> <p>Quickstart</p> MAUIAvaloniaUnoBlazorWPFWinUIWindows FormsEto Forms.NET for Android.NET for iOS <p>Step 1: Create a new .NET 7.0 MAUI application in Visual Studio.</p> <p>Step 2: Add the Mapsui.Maui nuget package:</p> <pre><code>dotnet add package Mapsui.Maui\n</code></pre> <p>Step 3: IMPORTANT: In MauiProgram.cs add .UseSkiaSharp() to the builder like this:</p> <pre><code>builder\n    .UseMauiApp&lt;App&gt;()\n    .UseSkiaSharp()\n    .ConfigureFonts(fonts =&gt;  \n</code></pre> <p>and add namespace 'SkiaSharp.Views.Maui.Controls.Hosting':</p> <pre><code>using SkiaSharp.Views.Maui.Controls.Hosting;\n</code></pre> <p>This is because Mapsui depends on SkiaSharp which needs this call. We hope that this will not be necessary in a future version of Mapsui.Maui. Without this line the app will crash with this exception: <code>Catastrophic failure (0x8000FFFF (E_UNEXPECTED))</code> on Windows and with <code>Microsoft.Mapsui.Platform.HandlerNotFoundException has been thrown</code> on Mac.</p> <p>Step 4: In MainPage.xaml.cs replace the constuctor with this code:</p> <pre><code>public MainPage()\n{\n    InitializeComponent();\n\n    var mapControl = new Mapsui.UI.Maui.MapControl();\n    mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\n    Content = mapControl;\n}\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <p>Preparation: Install the Avalonia templates:</p> <pre><code>dotnet new install Avalonia.Templates\n</code></pre> <p>Step 1: Create a new Avalonia project:</p> <pre><code>dotnet new avalonia.app -o MyApp\n</code></pre> <p>Step 2: Add the Mapsui.Avalonia nuget package:</p> <pre><code>cd MyApp\ndotnet add package Mapsui.Avalonia\n</code></pre> <p>Step 3: Update MainWindow.axaml to add the Mapsui namespace and MapControl:</p> <pre><code>&lt;Window xmlns=\"https://github.com/avaloniaui\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n+       xmlns:mapsui=\"clr-namespace:Mapsui.UI.Avalonia;assembly=Mapsui.UI.Avalonia\"\n        mc:Ignorable=\"d\" d:DesignWidth=\"800\" d:DesignHeight=\"450\"\n        x:Class=\"MyApp.MainWindow\"\n        Title=\"MyApp\"&gt;\n-    &lt;TextBlock Text=\"Welcome to Avalonia!\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"/&gt;\n+    &lt;mapsui:MapControl x:Name=\"MyMapControl\" /&gt;\n&lt;/Window&gt;\n</code></pre> <p>Step 4: Update MainWindow.axaml.cs to initialize the map:</p> <pre><code>using Avalonia.Controls;\n+using Mapsui.Tiling;\n\nnamespace MyApp;\n\npublic partial class MainWindow : Window\n{\n    public MainWindow()\n    {\n        InitializeComponent();\n+\n+        MyMapControl.Map?.Layers.Add(OpenStreetMap.CreateTileLayer());\n    }\n}\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <pre><code>dotnet run\n</code></pre> <p>Preparation: See Uno Platform getting started</p> <p>Step 1: Create new 'Uno Platform App' in Visual Studio</p> <p>Step 2: Add the Mapsui.Uno.WinUI nuget package:</p> <pre><code>dotnet add package Mapsui.Uno.WinUI\n</code></pre> <p>Repeat this for all the targets you are using</p> <p>Step 3: Open MainPage.xaml and add namespace:</p> <pre><code>xmlns:mapsui=\"clr-namespace:Mapsui.UI.WinUI;assembly=Mapsui.UI.Uno.WinUI\"\n</code></pre> <p>Add MapControl to the Grid:</p> <pre><code>&lt;Grid&gt;\n    &lt;mapsui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>In MainPage.xaml.cs, add namespace:</p> <pre><code>using Mapsui.Utilities;\n</code></pre> <p>Add code to the constructor:</p> <pre><code>public MainPage()\n{\n    this.InitializeComponent();\n    MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer());\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Troubleshooting:</p> <ul> <li> <p>Unable to resolve the .NET SDK version as specified in the global.json. global.json (change the version to \"6.0.400\" or what is installed on the Computer)</p> </li> <li> <p>Duplicate Attribute errors: Add following line to the ...Wpf.csproj.</p> </li> </ul> <pre><code>    &lt;!-- Work around https://github.com/dotnet/wpf/issues/6792 --&gt;\n    &lt;ItemGroup&gt;\n    &lt;FilteredAnalyzer Include=\"@(Analyzer-&gt;Distinct())\" /&gt;\n    &lt;Analyzer Remove=\"@(Analyzer)\" /&gt;\n    &lt;Analyzer Include=\"@(FilteredAnalyzer)\" /&gt;\n    &lt;/ItemGroup&gt;\n&lt;/Target&gt;\n</code></pre> <ul> <li>System.MissingMethodException: Method not found: See for solution here https://github.com/unoplatform/uno/issues/9297</li> </ul> <p>Upgrading to the latest Uno.UI Dev Version should help too.</p> <p>Step 1: Create a new Blazor WebAssembly Application in your IDE and select .NET 8.0 or later as Framework.</p> <p>Step 2: Add the Mapsui.Blazor nuget package:</p> <pre><code>dotnet add package Mapsui.Blazor\n</code></pre> <p>Step 3: In Home.razor (or Index.razor in older templates) add this to the Page.</p> <pre><code>@using Mapsui.UI.Blazor\n</code></pre> <pre><code>&lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;div class=\"col border rounded p-2 canvas-container\"&gt;\n            &lt;MapControlComponent @ref=\"_mapControl\" /&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n    .canvas-container canvas {\n        width: 100%;\n        height: 80vh;\n    }\n&lt;/style&gt;\n</code></pre> <pre><code>@code \n{\n    private MapControl? _mapControl;\n\n    protected override void OnAfterRender(bool firstRender)\n    {\n        base.OnAfterRender(firstRender);\n        if (firstRender)\n        {\n            if (_mapControl != null)\n                _mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\n        }\n    }\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Troubleshooting:</p> <ul> <li>Text is not displayed Add Following to the Blazor project, is a workaround that text is rendered.</li> </ul> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"HarfBuzzSharp.NativeAssets.WebAssembly\" Version=\"2.8.2.3\" GeneratePathProperty=\"true\" /&gt;\n    &lt;NativeFileReference Include=\"$(PKGHarfBuzzSharp_NativeAssets_WebAssembly)\\build\\netstandard1.0\\libHarfBuzzSharp.a\\3.1.12\\libHarfBuzzSharp.a\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>Prerequisites:</p> <ul> <li>Windows operating system</li> <li>.NET SDK 9.0 or later (the sample targets net9.0)</li> </ul> <p>Step 1: Create a new WPF project:</p> <pre><code>dotnet new wpf -n MapsuiWpfQuickstart -f net9.0\ncd MapsuiWpfQuickstart\n</code></pre> <p>Step 2: Add the required Mapsui packages:</p> <pre><code>dotnet add package Mapsui\ndotnet add package Mapsui.Wpf\n</code></pre> <p>Step 3: Replace the contents of <code>MainWindow.xaml</code> with:</p> <pre><code>&lt;Window x:Class=\"MapsuiWpfQuickstart.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:mapsui=\"clr-namespace:Mapsui.UI.Wpf;assembly=Mapsui.UI.Wpf\"\n        Title=\"Mapsui WPF Quickstart\" Height=\"450\" Width=\"800\"&gt;\n    &lt;Grid&gt;\n        &lt;mapsui:MapControl x:Name=\"mapControl\" /&gt;\n    &lt;/Grid&gt;\n&lt;/Window&gt;\n</code></pre> <p>Step 4: Replace the contents of <code>MainWindow.xaml.cs</code> with:</p> <pre><code>using System.Windows;\nusing Mapsui.Tiling;\n\nnamespace MapsuiWpfQuickstart\n{\n    public partial class MainWindow : Window\n    {\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            var map = new Mapsui.Map();\n            map.Layers.Add(OpenStreetMap.CreateTileLayer());\n            mapControl.Map = map;\n        }\n    }\n}\n</code></pre> <p>Step 5: Run the application:</p> <pre><code>dotnet run\n</code></pre> <p>You should see a map of the world with OpenStreetMap tiles.</p> <p>Step 1: Create new 'Blank App. Packaged (WinUI 3 in Desktop)' in Visual Studio</p> <p>Step 2: Add the Mapsui.WinUI nuget package:</p> <pre><code>dotnet add package Mapsui.WinUI\n</code></pre> <p>Step 3: Open MainPage.xaml and add namespace:</p> <pre><code>xmlns:winui=\"using:Mapsui.UI.WinUI\"\n</code></pre> <p>Add MapControl to the Grid:</p> <pre><code>&lt;Grid&gt;\n    &lt;winui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>In MainPage.xaml.cs, add namespace:</p> <pre><code>using Mapsui.Utilities;\n</code></pre> <p>Add code to the constructor:</p> <pre><code>public MainPage()\n{\n    this.InitializeComponent();\n    MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer());\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Start a new Windows Forms App in Visual Studio.</p> <p>Step 2: Add the Mapsui.WindowsForms nuget package:</p> <pre><code>dotnet add package Mapsui.WindowsForms\n</code></pre> <p>Step 3: In Form1.cs add this to the class constructor:</p> <pre><code>var mapControl = new MapControl();\nmapControl.Map.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\nControls.Add(mapControl);\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Start a new Eto.Forms application in Visual Studio.</p> <p>Step 2: Update the target framework in the main project's .csproj file from <code>netstandard2.0</code> to <code>net9.0</code> (Mapsui.Eto requires .NET 9.0 or later):</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;TargetFramework&gt;net9.0&lt;/TargetFramework&gt;\n&lt;/PropertyGroup&gt;\n</code></pre> <p>Step 3: Add the Mapsui.Eto nuget package:</p> <pre><code>dotnet add package Mapsui.Eto\n</code></pre> <p>Step 4: In MainForm.cs add this to the class constructor:</p> <pre><code>var mapControl = new Mapsui.UI.Eto.MapControl();\nmapControl.Map.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\nContent = mapControl;\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <p>Step 1: Create 'Blank App (Android)' in Visual Studio</p> <p>Step 2: Add the Mapsui.Android nuget package:</p> <pre><code>dotnet add package Mapsui.Android\n</code></pre> <p>Step 3: In Resources/layout/Main.axml add Mapsui.UI.Android.MapControl:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n    &lt;Mapsui.UI.Android.MapControl\n        android:id=\"@+id/mapcontrol\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Step 4: In MainActivity.cs add MapControl after SetContentView(Resource.Layout.Main):</p> <pre><code>protected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    // Set our view from the \"main\" layout resource\n    SetContentView(Resource.Layout.Main);\n\n    var mapControl = FindViewById&lt;MapControl&gt;(Resource.Id.mapcontrol);\n    var map = new Map();\n    map.Layers.Add(OpenStreetMap.CreateTileLayer());\n    mapControl.Map = map;\n}\n</code></pre> <p>Add the following using statements:</p> <pre><code>using Mapsui;\nusing Mapsui.Utilities;\nusing Mapsui.UI.Android;\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <p>Step 1: Create new 'Single View App' in Visual Studio</p> <p>Step 2: Add the Mapsui.iOS nuget package:</p> <pre><code>dotnet add package Mapsui.iOS\n</code></pre> <p>Step 3: Open ViewController.cs and add namespaces:</p> <pre><code>using Mapsui;\nusing Mapsui.UI.iOS;\nusing Mapsui.Utilities;\n</code></pre> <p>add code to ViewDidLoad() method:</p> <pre><code>public override void ViewDidLoad()\n{\n    base.ViewDidLoad();\n\n    var mapControl = new MapControl(View.Bounds);\n    var map = new Map();\n    map.Layers.Add(OpenStreetMap.CreateTileLayer());\n    mapControl.Map = map;\n    View = mapControl;\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p>"},{"location":"#functionality","title":"Functionality","text":"<ul> <li>Points, Lines and Polygons using NTS, a mature library which support all kinds of geometric operations. </li> <li>OpenStreetMap tiles based on BruTile library and almost all other tile sources.</li> <li>OGC standards with data providers for WMS, WFS and WMTS.</li> <li>Offline maps are possible using MBTiles implemented with BruTile.MBTiles. This stores map tiles in a sqlite file.</li> <li>Generates static map images to could be embedded in PDFs. </li> </ul>"},{"location":"#other-resources","title":"Other resources:","text":"<ul> <li>API documentation Mapsui</li> <li>Mapsui on GitHub</li> <li>Online samples in Blazor for Mapsui</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For paid support in the form of contract work or consulting mail: info.mapsui@gmail.com.</p>"},{"location":"async-fetching/","title":"Asynchronous Data Fetching","text":""},{"location":"async-fetching/#asynchronous-data-fetching","title":"Asynchronous Data Fetching","text":""},{"location":"async-fetching/#some-background","title":"Some background","text":"<p>To get smooth performance while panning and zooming data needs to be fetched on a background thread. Even if it is fetched on a background thread it will use resources which could be noticeable in the responsiveness of the map. The asynchronous data fetching of Mapsui tries to take this into account to optimize the user experience.</p>"},{"location":"async-fetching/#changetype","title":"ChangeType","text":"<p>(ChangeType was introduced in V3; in V2 the majorType boolean had this purpose)</p> <p>When calling the RefreshData method on the layers, we pass in a ChangeType parameter which could be:</p> <ul> <li>Continuous - During dragging, pinch zoom, or animations.</li> <li>Discrete - On zoom in/out button press, on touch up, or at the end of an animation.</li> </ul> <p>The layers themselves decide how to respond to the refresh call. For different data types, different strategies are used.</p>"},{"location":"async-fetching/#tilelayer-data-fetching","title":"TileLayer data fetching","text":"<p>The diagram below shows how the TileLayer's data fetcher works. The data fetcher runs on a background thread. The UI and Fetcher communicate through non-blocking messages. Whenever the user pans or zooms, the UI sends a message to the fetcher.</p>"},{"location":"async-fetching/#readwrite-cache","title":"Read/Write cache","text":"<p>For rendering, the cache is only read. For data fetching, the cache is primarily written to, but it also needs to read the cache in order to know which data is already available and does not need to be fetched again.</p>"},{"location":"async-fetching/#strategies","title":"Strategies","text":"<p>Both the fetcher and the renderer can use some smart tricks to optimize the experience, for example:</p> <ul> <li>The fetcher can pre-fetch tiles that are not directly needed but could be in the future.</li> <li>The renderer could search for alternative tiles (higher or lower levels) when the optimal tiles are not available. </li> </ul> <p>The implementation of these strategies can be overridden by the user by implementing interfaces that can be passed into the TileLayer constructor.</p> <ul> <li>The IDataFetchStrategy (IFetchStrategy in V2) determines which tiles are fetched from the data source to be stored in the cache. There is a DataFetchStrategy default implementation and a MinimalDataFetchStrategy implementation.</li> <li>The IRenderFetchStrategy (IRenderGetStrategy in V2) determines which tiles are fetched from the cache to use for rendering. There is a RenderFetchStrategy default implementation and a MinimalRenderFetchStrategy implementation.</li> </ul> <p>Those strategies should be tuned to support each other. For instance, in the current implementation, the renderer uses higher level tiles when the optimal tiles are not available, and the fetcher pre-fetches tiles that are likely to be requested soon.</p> <p></p>"},{"location":"async-fetching/#data-fetching-in-other-layers","title":"Data fetching in other layers","text":"<p>Other layers like the Layer and ImageLayer have their own implementation. They use a delay mechanism in fetching new data and ignore ChangeType.Continuous.</p>"},{"location":"contributors-guidelines/","title":"Mapsui Contributor Guidelines","text":""},{"location":"contributors-guidelines/#mapsui-contributor-guidelines","title":"Mapsui Contributor Guidelines","text":"<p>Note</p> <p>This documents contains a list of contibutor guidelines. The items were added on random moments when we felt it could be useful to add them. This is not a complete list or an overview.</p>"},{"location":"contributors-guidelines/#sign-the-cla","title":"Sign the CLA","text":"<p>If you want to contribute, you need to sign the Contributor License Agreement (CLA)</p> <p></p>"},{"location":"contributors-guidelines/#issues-first","title":"Issues first","text":"<p>Submit an issue before a pull request so we can discuss possible solutions to the problem.</p>"},{"location":"contributors-guidelines/#create-small-prs-focused-on-one-topic","title":"Create small PRs focused on one topic","text":"<p>To be able to review a PR, it helps if it is a small change that covers only one topic. For the reviewer, it is important to understand the purpose. Take the reviewer along in your thought process. There was a problem; you considered solutions; and there was a reason why you arrived at this solution. The diff shows what has changed, so it is not necessary to explain this (but it is useful to summarize it). What should be clear from the PR description, commit messages, and code comments is the \"why.\"</p>"},{"location":"contributors-guidelines/#use-a-chain-of-prs-for-bigger-changes","title":"Use a chain of PRs for bigger changes","text":"<p>When you need bigger changes you can use a chain of PRs where one depends on the other, this is preferred over one big PR. So first change the core parts and turn that into a separate PR that is easy to review. In a second PR that depends on that you should add a single line to the top of the first comment that says something like this:<code>Depends on #2722</code>. Once the previous PR has been merged, you can update the next one with <code>git pull origin main</code> on the command line, or use the 'Update Branch' button on Github. </p> <p>Only use dependencies when you need them. If you can make changes with a couple of independent PRs this is be preferred.</p>"},{"location":"contributors-guidelines/#formatting","title":"Formatting","text":"<p>We use .editorconfig in our repository, and the code should conform to it.</p> <p>In Visual Studio, you can check for compliance via the context menu in Solution Explorer by selecting <code>Analyze and Code Cleanup</code> and then <code>Run Code Analysis</code>. The results will show up in the <code>Error List</code> with <code>Build and IntelliSense</code> selected.</p> <p>Alternatively, you can use the <code>dotnet format</code> command.</p>"},{"location":"contributors-guidelines/#all-checks-should-be-green-all-the-time","title":"All checks should be green all the time","text":"<p>At all times:</p> <ul> <li>All projects should compile</li> <li>The unit tests should succeed</li> <li>All samples should run properly</li> </ul>"},{"location":"contributors-guidelines/#keep-the-core-code-simple-and-move-potentially-problematic-code-up-to-the-surface-projects","title":"Keep the core code simple and move potentially problematic code up to the surface projects","text":"<p>Code depends on other code. In a hierarchy, it is better to have high-quality code that is reliable and predictable in the core. You don't want potential problems to be propagated from the core to all other code because then everything becomes problematic. Potential problems are:</p> <ul> <li><code>IDisposable</code> objects. You don't want callers to have to deal with that. You don't want other code to have to decide whether to dispose or not.</li> <li>Code that uses <code>async</code>/<code>await</code>. Synchronous code is simpler. Calls are <code>async</code>/<code>await</code> because of long-running operations, which is often due to calls to external services. Those depend on the network, which could be slow or unavailable, and on the size of the data, which could be larger than expected.</li> <li>Code that could throw exceptions, forcing the caller to catch them - or perhaps the caller should not need to catch them (it's better if you do not have to decide).</li> <li>Fields that are nullable. Check for null early at the surface before passing it along to the core.</li> </ul> <p>A practical example of a problematic design in our own code is the dependency chain of: <code>DataSource &lt;- Fetcher &lt;- Layer &lt;- Map &lt;- MapControl</code>. The <code>DataSource</code> is disposable, and because of this, all other classes become disposable. We want to improve this by moving the disposable parts to a centralized data fetcher.</p>"},{"location":"contributors-guidelines/#prefer-pure-functions-and-immutable-data","title":"Prefer pure functions and immutable data","text":"<p>This is related to the paragraph above. In general, it is considered a good thing to use pure functions; however, you may need to reorganize things on a more global scale to make this possible.</p>"},{"location":"contributors-guidelines/#extension-methods","title":"Extension methods","text":"<ul> <li>Extension methods should always be in an <code>Extensions</code> folder.</li> <li>They should be in a class named <code>{ClassItExtends}Extensions</code>.</li> <li>They should be in a namespace that follows the folder name (so, not in the namespace of the class it extends).</li> <li>Extensions of a collection (<code>IEnumerable</code>, <code>List</code>, <code>Array</code>, etc.) of a type should also be in the class that extends the individual type.</li> <li>If an interface is extended, the <code>I</code> should not be part of the class name. So, a class with extensions of <code>ILayer</code> should be called <code>LayerExtensions</code>.</li> </ul>"},{"location":"contributors-guidelines/#pr-titles-should-be-written-as-release-notes","title":"PR titles should be written as release notes","text":"<p>GitHub can generate release notes from PR titles, so the PR titles should be written as release-note entries. Let's do it like this:</p> <ul> <li>Use imperative mood. See more about this in this post about commit messages (which should also use imperative mood). Most of the time, the title will begin with a verb, like Fix, Update, or Add.</li> <li>Don't put the issue number in the title; put it in the branch name (in the format suggested by GitHub when you click the \"create a branch\" link next to an issue). It will automatically be associated with the issue.</li> <li>The title should be self-explanatory, and its interpretation should not depend on the content of the issue it is referring to.</li> <li>The title should be succinct. It cannot always be a full description. Users can read the rest in the PR itself. There is a link to the PR next to the entry.</li> </ul>"},{"location":"contributors-guidelines/#ordering-of-lonlat","title":"Ordering of lon/lat","text":"<ul> <li>In our code, we prefer a lon, lat order consistent with the x, y order of most cartographic projections.</li> <li>Some background: The order of lon and lat always causes a lot of confusion. The official notation is lat, lon, but in map projections the lat corresponds to the y-axis and the lon to the x-axis. This is confusing because, in mathematics, the ordering is the other way around: x, y. In our code, we need to translate the lat/lon to an X/Y coordinate to draw it on the map. In the constructor of such a point, the x (lon) will be the first parameter. There is no way this problem can be fundamentally solved; there will always be some confusion. To mitigate it, we choose one way of ordering, which is lon, lat (consistent with x, y).</li> <li>Also, there are many ways in which we can avoid ordering altogether. For instance, if we work with <code>Longitude</code> and <code>Latitude</code> properties. In the case of <code>SphericalMercator.FromLonLat</code>, we use lon/lat in the method name to avoid confusion.</li> </ul>"},{"location":"contributors-guidelines/#no-rendering-in-the-drawpaint-loop","title":"No rendering in the draw/paint loop","text":"<p>Mapsui strives for optimal performance, so in the rendering loop, the objects should be ready to be painted to the canvas directly without any need for preparation. This is currently (4.1.0) not the case. For instance, in the case of tiles, they are rendered on the first iteration; after that, the cached version is used. This needs to be improved.</p>"},{"location":"contributors-guidelines/#about-the-terminology","title":"About the terminology","text":"<p>Rendering: Create a platform specific resource. </p><pre><code>SKPath path = ToSKPath(feature, style);\n</code></pre> Drawing or Painting: Draw the platform specific resource to the canvas. <pre><code>canvas.DrawPath(path, paint);\n</code></pre><p></p>"},{"location":"contributors-guidelines/#keep-the-renderer-behind-and-interface","title":"Keep the renderer behind and interface","text":"<p>As of v4 Mapsui has only one renderer, SkiaSharp. Although we have only one renderer and have currently no plans to add others we will keep it behind an interface. There are costs to keeping the abstraction but we keep it because a change could happen again, even though it does not seem likely now. In the past we had to switch renderers many times, a list:</p> <ul> <li>System.Drawing</li> <li>System.Drawing for PocketPC</li> <li>Silverlight XAML</li> <li>WPF XAML</li> <li>UWP XAML (could later be merged with WPF XAML)</li> <li>iOS native rendering</li> <li>Android native rendering (this is actually internally using skia)</li> <li>OpenTK (this was not mature enough at that point)</li> <li>SkiaSharp</li> </ul>"},{"location":"contributors-guidelines/#mapsui-should-not-be-limited-to-a-single-coordinate-system","title":"Mapsui should not be limited to a single coordinate system","text":"<p>Mapsui's Map can be in any coordinate system. If you do not specify a coordinate system in the Map and Layers it assumes they are in the same coordinate system (whatever they are). In this case it only transforms these unspecified 'world-coordinates' to 'screen-coordinates' and nothing more. It is also possible to setup a coordinate transformation system using Map.CRS, DataSource.CRS and Map.Transformation. See projections.</p>"},{"location":"contributors-guidelines/#full-implementation-of-the-feature-matrix","title":"Full implementation of the feature matrix","text":"<p>These are some of the feature dimensions:</p> <ul> <li>Renderers: WPF and Skia</li> <li>Geometries: Point, LineString, Polygon etc.</li> <li>Operations on Geometries: Distance, Contains.</li> <li>Coordinate projection support</li> <li>Style: fill color, line color, line cap, symbol opacity, symbol scale </li> </ul> <p>If we choose to support a feature each 'cell' of the multi dimensional matrix should be supported. No surprises for the user. At the moment (v4.1.0) there are holes in the matrix on some point (like differences between the various platforms). </p>"},{"location":"contributors-guidelines/#put-effort-in-keeping-things-simple","title":"Put effort in keeping things simple","text":"<p>Growing complexity is one of the biggest problems in software development. To keep this project maintainable we should put effort in keeping the complexity low. Complexity can be caused by clueless spaghetti code but also by astronaut architectures. Keeping things simple is not easy but hard work. It involves thinking up several solutions to your problem weighing the pros and cons and moving it around and upside down to look for even better (simpler) solutions. </p>"},{"location":"contributors-guidelines/#continuous-refactoring","title":"Continuous Refactoring","text":"<p>Mapsui contains some older code. Don't despair. We continuously improve or replace older code. It is a gradual process. We do it step by step. Although the steps are small we have managed to make major changes in the past: from WinForms to WPF, from GDI+ to SL rendering, from .NET Framework to PCL, from PCL to .NET Standard, from WPF rendering to SkiaSharp, from Mapsui geometries to NTS. Taking such steps results in breaking changes. We are aware of this and clearly communicate it with the user. We use semver so breaking changes go in to major version upgrades.</p>"},{"location":"custom-style-renders/","title":"Custom Style Renderers","text":""},{"location":"custom-style-renders/#custom-style-renderers","title":"Custom Style Renderers","text":""},{"location":"custom-style-renders/#summary","title":"Summary","text":"<p>Mapsui 2.0 supports custom style renderers. This means a user can create a custom style and associate this with a custom style renderer to allow full freedom in rendering a feature the way the user would like.</p>"},{"location":"custom-style-renders/#how-it-works","title":"How it works","text":"<ul> <li>Create a custom style by deriving a class from IStyle. </li> <li>Assign that style to an ILayer.Style or IFeature.Styles.</li> <li>Create a custom renderer by deriving a class from ISkiaStyleRenderer and implement the Draw method.</li> <li>Register the association of the custom style to the custom style renderer as in the line below. The consequence will be that if the Mapsui renderer detects this style it will call the Draw method on the style renderer. </li> </ul> <p>This is how you register the association of a custom style to a custom style renderer </p><pre><code>mapControl.Renderer.StyleRenderers.Add(typeof(CustomStyle), new SkiaCustomStyleRenderer());\n</code></pre><p></p> <p>This is the ISkiaStyleRenderer interface that you need to implement: </p><pre><code>public interface ISkiaStyleRenderer : IStyleRenderer\n{\n  bool Draw(SKCanvas canvas, IReadOnlyViewport viewport, ILayer layer, IFeature feature, IStyle style, IRenderService renderService, long iteration);\n}\n</code></pre><p></p> <p>The IFeature has a Geometry field. The renderer is responsible to cast the IFeature.Geometry to the type it intends to render. The IStyle is the custom style the user defined. It could contain extra style information not present in the default style classes. The user will need to cast that IStyle to the custom style to use this extra information.</p>"},{"location":"custom-style-renders/#code-sample","title":"Code sample","text":"<p>Look in the Mapsui source code for CustomStyleSample.cs. </p> <p></p> <p>This is the most relevant code. In this sample the custom style contains no extra information, it is just an indication to use the associated custom renderer. It would be possible to add extra field like EarColor and NoseSize to the custom style which could be used in the renderer.</p>"},{"location":"custom-style-renders/#remarks","title":"Remarks","text":"<p>Note, that the renderer depends on the technology we use for the rendering implementation which is SkiaSharp. Theoretically we could change this implementation or add other implementations but there are no plans for that.</p>"},{"location":"documentation-of-v4/","title":"Documentation of v4","text":""},{"location":"documentation-of-v4/#documentation-of-v4","title":"Documentation of v4","text":"<p>If you are looking for documentation for Mapsui v4, you can find it here:</p> <ul> <li>The v4 general documentation</li> <li>The v4 API documentation</li> <li>The v4 Online samples in Blazor</li> </ul>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#documentation","title":"Documentation","text":""},{"location":"documentation/#documentation-setup","title":"Documentation setup","text":"<ul> <li>We use mkdocs to generate the general documentation. The main configuration is in <code>./docs/general/mkdocs.yml</code>. You can test it locally by running <code>mkdocs serve</code> in that folder. The content is in the .md files in the <code>./docs/general/markdown</code> folder. To update the documentation those files need to be edited. The documentation web site has a link back to these files on github to make it easy to update them. The general docs are published to the <code>./docs/general/_site</code> folder.</li> <li>We use docfx to generate the api documentation. The main configuration is in <code>./docs/api/docfx.json</code>. You can test it locally by running <code>docfx --serve</code> in that folder. The api docs are published to the <code>./docs/api/_site</code> folder.</li> <li>The powershell script <code>./Scripts/BuildDocumentationWebSite.ps1</code> runs both mkdocs and docfx and copies both to the <code>./website</code> folder.</li> <li>The Mapsui project on github is configured to automatically publish the <code>./website</code> folder to github pages: https://mapsui.github.io/Mapsui, configured for the mapsui.com domain: https://mapsui.com.</li> <li>A pushed commit of a markdown file triggers the <code>dotnet-docs.yml</code> github action. It will run the scripts and automatically publish the new version to the website. </li> </ul>"},{"location":"documentation/#documentation-setup-guidelines","title":"Documentation setup guidelines","text":"<ul> <li>All md files should be in lower case.</li> <li>All md files should be directly in the <code>./docs/general/markdown</code> folder, not in a subdirectory. Hierarchy is created by indenting page references in the toc.md in the documentation folder. By keeping the files in the root it is easier to change the hierarchy later on - you do not need to move the files as well - and it is easier to stick to the guidelines.</li> <li>All md files should start with a header one (#) and should have no other header one in the file.</li> <li>All the headers in the toc should be equal to the header one in the file it points to.</li> </ul>"},{"location":"documentation/#documentation-guidelines","title":"Documentation guidelines","text":"<ul> <li>Mapsui is cased as Mapsui not MapsUI.</li> <li>We should iteratively improve the documentation. If questions are asked in the issues we should search for the answer in the documentation. When something is missing in the documentation update the documentation and answer the question with a url to the documentation.</li> <li>Writing documentation is not only useful to inform the user but also as a sanity check for the developer. If what you have to tell becomes complicated and hard to grasp this could mean the software is not well designed. Writing documentation early should be used as a part of the software development process.</li> </ul>"},{"location":"experimental-packages/","title":"Experimental Packages","text":""},{"location":"experimental-packages/#experimental-packages","title":"Experimental Packages","text":"<p>With the release of Mapsui v5, we will introduce experimental NuGet packages. These packages will contain new functionality that is compatible with the v5 stable packages. These experimental packages could contain breaking changes on patch releases and will have more bugs.</p>"},{"location":"experimental-packages/#why-experimental-packages","title":"Why Experimental Packages?","text":"<p>During the development of v5, there was a big gap between the stable release and the new developments in the betas. It was only possible to use the new functionality by fully migrating to v5. This was not always possible and was only done by a few early adopters. By releasing experimental packages, this gap will be smaller. It will be possible to start using some experimental parts while primarily depending on the stable package. So, there is no need for a big migration, and reverting from an experiment would also not be hard. With this setup, we also hope to receive earlier feedback on our new functionality.</p>"},{"location":"experimental-packages/#how-is-this-organized","title":"How is this organized?","text":"<p>We will keep all development in the main branch. Stable projects will remain mostly unchanged except for bug fixes. New experimental projects will be added to the main branch and will be published in their own NuGet packages. At the moment of writing, we have these experimental packages:</p> <ul> <li><code>Mapsui.Experimental</code> \u2013 Code that belongs in the Mapsui core project but is in an experimental stage.</li> <li><code>Mapsui.Experimental.VectorTiles</code> \u2013 Implementation of vector tile rendering which is currently in an experimental stage.</li> </ul> <p>We will also add:</p> <ul> <li><code>Mapsui.Experimental.Rendering.Skia</code> \u2013 In this package we will do a substantial rewrite of the rendering.</li> </ul>"},{"location":"experimental-packages/#branching-before-the-next-release","title":"Branching before the next release","text":"<p>At some point before the release of v6, we will need to introduce breaking changes in the main Mapsui projects. At that point, we will need to branch the stable version off to develop/5.0. We will try to postpone this for a while and will try to keep the period between branching and releasing short.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"faq/#the-openstreetmap-layer-does-not-show","title":"The openstreetmap layer does not show","text":"<p>The most common reason is that the default user-agent used by the osm layer is blocked.  The default user-agent gets blocked by osm at some point because there is always someone somewhere abusing the api. Within your app you need to use a user-agent that is specific to your app. We change the user agent from time to time so that the samples work but it will probably get blocked again at some point. Better not to wait until that happens and create you own user-agent right away.</p> <pre><code>MapControl.Map.Layers.Add(OpenStreetMap.CreateTileLayer(\"your-user-agent\"));\n</code></pre>"},{"location":"faq/#why-is-all-my-data-in-a-small-area-near-the-west-coast-of-africa","title":"Why is all my data in a small area near the west coast of Africa?","text":"<p>This is because the background data is in SphericalMercator (it is in the SphericalMercator  coordinate system) and the foreground data is in WGS84 (latlon). Use  SphericalMercator.FromLonLat to transform it. Note: There can be many other forms of mixing up coordinate systems, but this is the most common.</p>"},{"location":"faq/#why-does-navigateto-zoom-into-an-area-near-the-west-coast-of-africa","title":"Why does NavigateTo zoom into an area near the west coast of Africa?","text":"<p>This is because the coordinates you pass to NavigateTo are in WGS84 whereas the background data is in SphericalMercator. Use SphericalMercator.FromLonLat to transform  the NavigateTo arguments to SphericalMercator. Note: There can be many other forms of mixing up coordinate systems, but this is the most common.</p>"},{"location":"faq/#how-can-i-get-rid-of-the-white-dots-or-black-lines","title":"How can I get rid of the white dots? (or black lines)","text":"<p>Set <code>Layer.Style = null</code>. In Mapsui a Style can be assigned to a ILayer and a Feature. A Layer is created with a default style which is rendered as a white dot for a <code>Point</code>, a black line for a <code>LineString</code> and a black outline for a <code>Polygon</code>. The <code>Layer.Style</code> applies to all features in the layer. If you work with a style on a feature the layer style is still drawn underneath.  </p>"},{"location":"imagesource/","title":"Images","text":""},{"location":"imagesource/#images","title":"Images","text":"<p>In Mapsui v5 the Image class was added which simplifies the process of working with images. Previously, in v4, you had to load the image in your code, register it, and then assign the image ID returned from the registration to the symbol. Now all you have to do is assign the path to the image to the Source field of the Image class.</p>"},{"location":"imagesource/#supported-path-schemes-for-the-source","title":"Supported Path Schemes for the Source","text":"<p>Mapsui supports five types of schemes for specifying image paths: </p> <ul> <li>http(s)://, for pointing images on a remote server.</li> <li>file://, for pointing to images on the local file system.</li> <li>embedded://, for pointing to images in the dotnet embedded resources.</li> <li>svg-content://, for strings that contain the SVG xml itself.</li> <li>base64-content://, for strings containing base64 encoded images.</li> </ul> <p>Here are some examples:</p> <pre><code>myStyle.Image.Source = \"https://mapsui.com/images/logo.svg\";\nmyStyle.Image.Source = $\"file://{Environment.SpecialFolder.LocalApplicationData}/example.png\"\nmyStyle.Image.Source = \"embedded://Mapsui.Resources.Images.Pin.svg\"\nmyStyle.Image.Source = \"svg-content://&lt;svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"36\\\" height=\\\"56\\\"&gt;&lt;path d=\\\"M18 .34C8.325.34.5 8.168.5 17.81c0 3.339.962 6.441 2.594 9.094H3l7.82 15.117L18 55.903l7.187-13.895L33 26.903h-.063c1.632-2.653 2.594-5.755 2.594-9.094C35.531 8.169 27.675.34 18 .34zm0 9.438a6.5 6.5 0 1 1 0 13 6.5 6.5 0 0 1 0-13z\\\" fill=\\\"#ffffff\\\" stroke=\\\"#000000\\\"/&gt;&lt;/svg&gt;\")]\nmyStyle.Image.Source = \"base64-content://PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNiIgaGVpZ2h0PSI1NiI+PHBhdGggZD0iTTE4IC4zNEM4LjMyNS4zNC41IDguMTY4LjUgMTcuODFjMCAzLjMzOS45NjIgNi40NDEgMi41OTQgOS4wOTRIM2w3LjgyIDE1LjExN0wxOCA1NS45MDNsNy4xODctMTMuODk1TDMzIDI2LjkwM2gtLjA2M2MxLjYzMi0yLjY1MyAyLjU5NC01Ljc1NSAyLjU5NC05LjA5NEMzNS41MzEgOC4xNjkgMjcuNjc1LjM0IDE4IC4zNHptMCA5LjQzOGE2LjUgNi41IDAgMSAxIDAgMTMgNi41IDYuNSAwIDAgMSAwLTEzeiIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMDAwMDAwIi8+PC9zdmc+\")]\nmyStyle.Image.Source = \"base64-content://iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAcUlEQVQ4y+VUyw7AIAgrxgtf4v9/HZ5kF90M6JK9siVruGGlNFVSVZxFwAXMyURrlZwPTy4i2F3qIdmfJsfNW4/mVmAetqI/alV5w9uku3buUlGzIQJAU7ItS1a11cmraTHdf4dkeDEzAAJmL4te+0kWaRI0VGH3VHwAAAAASUVORK5CYII=\"\n</code></pre>"},{"location":"imagesource/#supported-image-source-types","title":"Supported Image Source Types","text":"<p>An Image Source can point to or contain an SVG (supported via Svg.Skia) or a bitmap type, which can be PNG, WEBP, JPEG, and any other format supported by SkiaSharp.</p>"},{"location":"imagesource/#image-usage","title":"Image usage","text":"<p>The following Mapsui classes have an Image field:</p> <ul> <li>ImageStyle</li> <li>CalloutStyle</li> <li>Brush</li> <li>ImageButtonWidget</li> </ul>"},{"location":"imagesource/#bitmapregion","title":"BitmapRegion","text":"<p>If the Source refers to a bitmap type (so PNG or webp, not SVG), you can specify a sub-region of the bitmap to use. This is useful for utilizing a smaller part of a bitmap or working with a meta image (or atlas) that contains multiple smaller images. </p>"},{"location":"imagesource/#custom-svg-colors","title":"Custom SVG colors","text":"<p>If the Source refers to an SVG, you can override the built-in colors of the stroke and fill with:</p> <ul> <li>SvgFillColor</li> <li>SvgStrokeColor</li> </ul> <p>This feature offers great flexibility, allowing you to, for instance, indicate different types of vehicles or different states of a single vehicle. </p> <p>Warning</p> <p>Note that a new instance of the SVG object needs to be stored in memory for every different color. So you need to keep some restraint on the number of colors used. An example where this could cause trouble is if you use a float value in a calculation to determine the color, for instance if you let the speed of a vehicle determine the color. To circumvent this you could use categories. Many SVG object instances can also impact performance. If a single color suffices you could use BlendColorMode as an alternative to SvgFillColor/SvgStrokeColor. </p>"},{"location":"logging/","title":"Logging","text":""},{"location":"logging/#logging","title":"Logging","text":"<p>Sooner or later there comes a time where you are struggling with a bug. You can save yourself some time by writing the Mapsui log events to your own log from the start of your project. In Mapsui errors and warnings are logged to a static class which has an event handler you can listen to. You can paste the code below anywhere in your app to start receiving log messages.</p> <pre><code>Mapsui.Logging.Logger.LogDelegate += (level, message, ex) =&gt;\n{\n    Console.WriteLine($\"{message} {ex?.Message}\"); // &lt;-- Put a break point here, most UI platforms do not show the console logging.\n    // todo: Forward to your own logger\n};\n</code></pre>"},{"location":"logging/#forward-mapsui-logging-to-ilogger","title":"Forward Mapsui logging to ILogger","text":"<p>This is an example of how to forward Mapsui logging to the de facto standard <code>Microsoft.Extensions.Logging.ILogger</code>. If you have configured a logger in your app, like serilog for instance, you would get Mapsui log messages in that log file. </p><pre><code>    public static void AttachMapsuiLogging(this IServiceProvider serviceProvider)\n    {\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;MyLoggerCategory&gt;&gt;();\n\n        var mapsuiPrefix = \"[Mapsui]\";\n\n        Mapsui.Logging.Logger.LogDelegate += (level, message, ex) =&gt; {\n            if (level == Mapsui.Logging.LogLevel.Error)\n                logger.LogError(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Warning)\n                logger.LogWarning(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Information)\n                logger.LogInformation(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Debug)\n                logger.LogDebug(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Trace)\n                logger.LogTrace(ex, $\"{mapsuiPrefix} {message}\");\n        };\n    }\n</code></pre><p></p>"},{"location":"logging/#show-logging-in-the-map","title":"Show logging in the map","text":"<p>It is possible to show all Mapsui logging in the map. There are three possible configurations Yes, No, and OnlyInDebugMode.  That last one is the default and it means that the logging will show if the debugger is attached and not when it is not attached (Note, that this is not the same thing as building in Debug or Release mode, you can run either build with or without the debugger  attached). In most scenarios this is what you want and you don't have to change anything for a release of your app. </p> <p>In some cases you want to enable it for the released app. For instance if you need to debug something that happens only with the released app.  In that case you can set the static LoggingWidget.ShowLoggingInMap field to Yes: </p><pre><code>LoggingWidget.ShowLoggingInMap = ActiveMode.Yes;\n</code></pre><p></p> <p>In other cases you want to disable it when debugging. For instance if you want to see how things look when the app is released. In that case you can set the static LoggingWidget.ShowLoggingInMap field to No: </p><pre><code>LoggingWidget.ShowLoggingInMap = ActiveMode.No;\n</code></pre><p></p> <p>Logging in the map is implemented through the LoggingWidget which is added by default to the Map class. Usually you can just leave it there. If you remove or disable it no logging will be shown in the map.</p> <p>The logging settings are global, so if you have two maps in your app both will be affected by the ShowLoggingInMap  setting.</p>"},{"location":"logging/#logging-of-map-and-widget-pointer-events","title":"Logging of Map and Widget pointer events","text":"<p>It is possible to enable logging of the Map and/or Widget pointer events by changing the settings of the static Logger: </p><pre><code>Logger.Settings.LogMapEvents = true;\nLogger.Settings.LogWidgetEvents = true;\n</code></pre> This is especially useful if you are trying to get widgets to work, or are developing your own widget.<p></p>"},{"location":"mapinfo/","title":"MapInfo","text":""},{"location":"mapinfo/#mapinfo","title":"MapInfo","text":"<p>The <code>MapInfo</code> class contains information about what is visible on a specific location on the map. You can get <code>MapInfo</code> by calling the <code>GetMapInfo</code> function on the EventArgs of manipulation event handlers (like <code>Info</code>, <code>Tapped</code>, <code>PointerPressed</code>, <code>PointerReleased</code>, <code>PointerMoved</code>). GetMapInfo takes a parameter to specify which layers to include in the MapInfo. The MapInfo class always contain the ScreenPosition and WorldPosition, but these are also directly available on all EventArgs.</p>"},{"location":"mapinfo/#changes-between-v4-and-v5","title":"Changes between V4 and V5","text":"<p>In V4 <code>MapInfo</code> was a field of the <code>MapInfoEventArgs</code> of the <code>Info</code> event. In V5 more event types are added. We do not want to tie MapInfo to any particular event and don't want to burden all events with fetching MapInfo. With the <code>GetMapInfo</code> function on all EventArgs the user can choose to request MapInfo or not. </p> <p>In different situations you want information from different layers (when editing, when showing feature info, when showing hover info). In V4 you had to set the ILayer.IsMapInfoLayer to true on a layer and would always get MapInfo on these layer on any call to <code>Info</code>. In V5 you can specify which layers to include on each call, making it more flexible.</p>"},{"location":"mapsui-components/","title":"Mapsui components","text":""},{"location":"mapsui-components/#mapsui-components","title":"Mapsui components","text":"<p>This part will talk about a few of Mapsui's core components. These are:</p> <ul> <li>MapControl: UI component to add to your page.</li> <li>Map: UI indepenent part which holds most of the state of the map. </li> <li>Navigator: Controls all mutations of the Viewport.</li> <li>Viewport: The state that defines which part is visible in the MapControl.</li> <li>MapRenderer: Draws the map in the MapControl.</li> </ul>"},{"location":"mapsui-components/#mapcontrol","title":"MapControl","text":"<p>This is the UI component that you add to you app. It is derived from a base UI component of the framework and inherits many properties related to that framework. You can control its size and positioning like any other component in your framework.</p>"},{"location":"mapsui-components/#map","title":"Map","text":"<p>The most important property of the MapControl is the Map. Unlike the MapControl the Map is platform independent. Most of the time you will be dealing with the Map or it's children. </p>"},{"location":"mapsui-components/#navigator","title":"Navigator","text":"<p>Is responsible for all Viewport manipulations, this includes:</p> <ul> <li>It checks <code>PanLock</code>, <code>ZoomLock</code>, <code>RotationLock</code>. </li> <li>It checks the pan bounds (<code>PanBounds</code>) and zoom bounds (<code>ZoomBounds</code>). Both depend on the kind of limiter that is used. </li> <li>It controls the animations. It makes sure only one viewport animation is executed at one time and a previous animation is cancelled before the new one is started. </li> <li>It calls a <code>FetchRequested</code> event on a discrete viewport change or at the end of an animation (after drag or pinch RefreshData needs to called from the MapControl touch up). </li> <li>It calls the <code>ViewportChanged</code> event on all viewport changes. </li> <li>It checks the validity of the viewport state (like if it has size) before any call is executed. </li> <li>It makes sure the resolution steps are used when using <code>ZoomIn</code>, <code>ZoomOut</code> or <code>MouseWheelZoom</code>.</li> </ul>"},{"location":"mapsui-components/#viewport","title":"Viewport","text":"<p>Defines what part of the map is visible on the screen. It is a simple immutable struct that contains just state. It is passed into the MapRenderer and data fetchers.</p>"},{"location":"mapsui-components/#maprenderer","title":"MapRenderer","text":"<p>A member of the MapControl. Draws the map on the MapControl when RefreshGraphics is called.</p>"},{"location":"nuget-of-latest-build/","title":"NuGet of Latest Build","text":""},{"location":"nuget-of-latest-build/#nuget-of-latest-build","title":"NuGet of Latest Build","text":"<p>Mapsui's 'Build' GitHub action creates nugets and stores them as artifacts. You can use them in your local build.</p> <ul> <li>Go to actions.</li> <li>Select the 'Build' workflow on the left.</li> <li>Select the specific build that you are interested in, for instance, the latest build on the 'main' branch.</li> <li>Scroll to the bottom to 'Artifacts' and download the artifacts of your OS.</li> <li>Extract the artifacts and place the .nupkg file in a folder, e.g., C:\\LocalNuGets.</li> <li>Run <code>dotnet nuget add source \"C:\\LocalNuGets\" --name LocalNuGet</code> in your sln folder to add the source to the nuget.config.</li> <li>You may need to specify the specific version of the nuget in the csproj or Directory.Package.props.</li> <li>Note, the version will have a build postfix and could look like '5.0.0-beta.7-37-g6bac058'.</li> </ul>"},{"location":"performance-widget/","title":"PerformanceWidget","text":""},{"location":"performance-widget/#performancewidget","title":"PerformanceWidget","text":""},{"location":"performance-widget/#summary","title":"Summary","text":"<p>Mapsui 3.0 supports a widget, that could show the main performance values for drawing the map.</p>"},{"location":"performance-widget/#how-it-works","title":"How it works","text":"<p>1) Create a new Performance object for the MapControl, where the values could be stored</p> <pre><code>if (mapControl.Performance == null)\n    mapControl.Performance = new Utilities.Performance(10);\n</code></pre> <p>2) Create the PerformanceWidget. As parameter you have to provide the Performance object, that the widget should use</p> <pre><code>var widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance);\n</code></pre> <p>3) If you want to clear all values of the Performance object, then add the following event handler for the touch event of the widget</p> <pre><code>widget.WidgetTouched += (sender, args) =&gt;\n{\n    mapControl?.Performance.Clear();\n    mapControl?.RefreshGraphics();\n\n    args.Handled = true;\n};\n</code></pre> <p>4) Add the widget to the list of known widgets</p> <pre><code>mapControl.Map.Widgets.Add(widget);\n</code></pre> <p>5) To draw the widget on the screen, we need a widget renderer. To use the default widget renderer, use the following lines</p> <pre><code>Mapsui.Rendering.SkiaMapRenderer.RegisterWidgetRenderer(typeof(Widgets.Performance.PerformanceWidget), \n  new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White));\n</code></pre> <p>The first two parameters are the X and Y coordinates for the widget. Third parameter is the text size. Fourth is the text color and fifth is the background color.</p>"},{"location":"performance-widget/#code-copy","title":"Code copy","text":"<pre><code>if (mapControl.Performance == null)\n    mapControl.Performance = new Utilities.Performance();\n\nvar widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance);\n\nwidget.WidgetTouched += (sender, args) =&gt;\n{\n    mapControl?.Performance.Clear();\n    mapControl?.RefreshGraphics();\n\n    args.Handled = true;\n};\n\nmapControl.Map.Widgets.Add(widget);\nMapsui.Rendering.SkiaMapRenderer.RegisterWidgetRenderer(typeof(Widgets.Performance.PerformanceWidget), \n  new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White));\n</code></pre>"},{"location":"performance-widget/#values","title":"Values","text":""},{"location":"performance-widget/#last","title":"Last","text":"<p>Time for drawing of the last screen. Be careful: because the widget is drawn together with the screen, this time is the time for the screen drawn before the screen you see.</p>"},{"location":"performance-widget/#mean","title":"Mean","text":"<p>The mean value is the mean of the last x draws. x is the number, you provide when creating the Performance object.</p>"},{"location":"performance-widget/#frames-per-second","title":"Frames per second","text":"<p>This is the number of frames that could be drawn with the actual mean drawing time.</p>"},{"location":"performance-widget/#minimum","title":"Minimum","text":"<p>Fastest draw of the screen.</p>"},{"location":"performance-widget/#maximum","title":"Maximum","text":"<p>Slowest draw of the screen.</p>"},{"location":"performance-widget/#count","title":"Count","text":"<p>How often the screen is drawn.</p>"},{"location":"performance-widget/#dropped","title":"Dropped","text":"<p>How often the screen isn't invalidated, because a drawing is still in progress.</p>"},{"location":"performance-widget/#remarks","title":"Remarks","text":"<p>The Performance object contains the times between start and end of a drawing process. This must not be the real drawing time. It could be, that other tasks running in between the drawing process.</p>"},{"location":"projections/","title":"Projections","text":""},{"location":"projections/#projections","title":"Projections","text":"<p>A geospatial projection involves converting coordinates from one coordinate system to another. If all your data is within a single coordinate system, projection is unnecessary. In the context of Mapsui, projection refers specifically to geospatial transformations, not to the conversion of spatial coordinates to pixel positions on a screen, even though both can be considered transformations.</p>"},{"location":"projections/#some-background-on-projections","title":"Some Background on Projections","text":"<p>Geospatial projections are complex, and explaining them can be challenging due to the varied backgrounds of Mapsui users. Some are experienced GIS professionals, while many are app developers needing a map for their application. Below are some basic concepts to help clarify this topic. I recommend watching this video for an introduction to map projections.</p>"},{"location":"projections/#spatial-reference-system-crs","title":"Spatial Reference System (CRS)","text":"<p>In geospatial contexts, coordinate systems are referred to by their Coordinate Reference System (CRS). In Mapsui, both the <code>Map</code> and the <code>IProvider</code> have a CRS field to specify their coordinate systems.</p>"},{"location":"projections/#supported-coordinate-systems-crses","title":"Supported Coordinate Systems (CRSes)","text":"<p>By default, Mapsui supports projections between two main coordinate systems:</p> <ul> <li>EPSG:4326, also known as WGS84 or lat/lon, which is used by GPS.</li> <li>EPSG:3857, also known as SphericalMercator, WebMercator, or PseudoMercator, which is used by Google Maps and OpenStreetMap.</li> </ul> <p>You can also create custom projections by implementing the <code>IProjection</code> interface and using a projection library like ProjNet4GeoAPI.</p>"},{"location":"projections/#parts-of-mapsui-involved-in-projections","title":"Parts of Mapsui Involved in Projections","text":"<ul> <li>Map: The map itself, which is always in a specific coordinate system.</li> <li>Layers: These provide data to be displayed on the map and must return data in the map's coordinate system to avoid errors from overlapping different projections.</li> <li>Providers: Data sources for layers. If the data is in a different coordinate system, it can be converted using the <code>ProjectingProvider</code>.</li> </ul>"},{"location":"projections/#the-most-common-scenario","title":"The Most Common Scenario","text":"<p>When using OpenStreetMap, the map is in SphericalMercator, but your geodata might be in lat/lon (e.g., a GPS track).</p> <ol> <li>Set <code>Map.CRS</code> to \"EPSG:3857\" if using SphericalMercator.</li> <li>Set <code>Provider.CRS</code> to \"EPSG:4326\" if your data is in lat/lon.</li> <li>Wrap the provider in the <code>ProjectingProvider</code>. Refer to the code samples for <code>ProjectingProvider</code>.</li> </ol> <p>The <code>ProjectingProvider</code> will handle the projection for you. Alternatively, you can manually project the data using <code>Mapsui.SphericalMercator.FromLonLat</code> and <code>ToLonLat</code> before adding it to a <code>MemoryLayer</code>, which eliminates the need to set CRSes.</p>"},{"location":"projections/#remarks","title":"Remarks","text":"<ul> <li>Mapsui does not support projecting images, such as raster tiles. The CRS fields are ignored for image projections.</li> </ul>"},{"location":"projections/#sample","title":"Sample","text":"<p>[!code-csharpMain]</p>"},{"location":"projects-that-use-mapsui/","title":"Projects That Use Mapsui","text":""},{"location":"projects-that-use-mapsui/#projects-that-use-mapsui","title":"Projects That Use Mapsui","text":""},{"location":"projects-that-use-mapsui/#breath-companion","title":"Breath Companion","text":""},{"location":"projects-that-use-mapsui/#droniq-maps","title":"Droniq Maps","text":""},{"location":"projects-that-use-mapsui/#lokqldx-kql-data-explorer","title":"LokqlDx - KQL data explorer","text":""},{"location":"projects-that-use-mapsui/#squadra","title":"Squadra","text":""},{"location":"projects-that-use-mapsui/#rutas-tarija","title":"Rutas Tarija","text":""},{"location":"rendering-tests/","title":"Rendering Tests","text":""},{"location":"rendering-tests/#rendering-tests","title":"Rendering Tests","text":"<p>Mapsui has rendering tests where images are generated and compared to reference images that are stored as file in the repository. They are regression tests but executed by our unit test framework. The images are compared pixel by pixel. If there are too many differences the test will fail. </p>"},{"location":"rendering-tests/#fix-the-code-or-update-the-image","title":"Fix the code or update the image?","text":"<p>If a test fails the developer needs to decide whether to:</p> <ul> <li>Accept the changes because the generated image is as intended.</li> <li>Change the code because the generated image is not as intended.</li> </ul> <p>To make this decision the developer needs to visually inspect the generated images. This can be done in two ways.</p>"},{"location":"rendering-tests/#inspect-the-sample-in-the-app","title":"Inspect the sample in the app","text":"<p>Every rendering test that can fail corresponds a sample. You can view any sample by running one of the sample apps (we have one for each platform). Even if you have not seen the reference image you can often spot a mistake by looking at the sample, it can be an obvious bug.  </p> <p>You need to know the name and the category of the sample. For this you need to look at the error of the failed test. Which could be:</p> <p></p><pre><code>Failed TestSampleAsync(Mapsui.Samples.Common.Maps.Tests.LineSample) [4 s]\n</code></pre> In this case the sample is in the file <code>LineSample.cs</code>. If you open that file you will see it is named <code>Line</code> and in category <code>Tests</code>.<p></p>"},{"location":"rendering-tests/#compare-the-generated-images","title":"Compare the generated images","text":"<p>The generated images are written to:</p> <pre><code>{Mapsui.slnx folder}\\Tests\\Mapsui.Rendering.Skia.Tests\\bin\\Debug\\net9.0\\Resources\\Images\\GeneratedRegression\n</code></pre> <p>You will need to compare those to the the original ones that have been copied to this folder as part of the build:</p> <pre><code>{Mapsui.slnx folder}\\Tests\\Mapsui.Rendering.Skia.Tests\\bin\\Debug\\net9.0\\Resources\\Images\\OriginalRegression\n</code></pre> <p>Such a folder would look like this:</p> <p></p>"},{"location":"rendering-tests/#update-the-image","title":"Update the image","text":"<p>If after code changes there are expected changes in the generated files they should be committed to git so they need to be copied to:</p> <pre><code>{Mapsui.slnx folder}\\Tests\\Mapsui.Rendering.Skia.Tests\\Resources\\Images\\OriginalRegression\n</code></pre> <p>My way of working is like this. I copy all original files over the original files with this command: </p><pre><code>PS&gt; .\\Scripts\\CopyGeneratedImagesOverOriginalImages.ps1\n</code></pre> Then there will be many git changes because smaller differences have been accepted by the tests in the past. You need to revert all files that did not cause a test to fail. This is because we want to reduce the number of changes in our git history, especially if they are binary files.<p></p>"},{"location":"resolution/","title":"Resolution","text":""},{"location":"resolution/#resolution","title":"Resolution","text":"<p>In Mapsui the resolution is a value that indicates to what degree the map is zoomed in or zoomed out. A large value means you are zoomed out (see the whole world), a small value means you are zoomed in (looking at the details). The resolution of a viewport is its size in map coordinates (of the coordinate system used) divided by its size in pixels. If you use the OpenStreetMap background layer (or another layer in that coordinates system) the resolution is meters / pixel at the equator.</p>"},{"location":"resolution/#the-resolution-of-the-mapsui-viewport","title":"The resolution of the Mapsui viewport","text":"<p>The Viewport is an important class in Mapsui. It has a Resolution field. Its value can be directly derived from the coordinate extent and the size in pixels. So Viewport.Resolution will always be equal to Viewport.Extent.Width / Viewport.Width. The Viewport.Extent is in the units of the coordinate system (different apps can use different coordinate systems) and the Viewport.Width/Height is in pixels.</p>"},{"location":"resolution/#the-resolution-in-openstreetmap","title":"The resolution in OpenStreetMap","text":"<p>Mapsui's resolution concept is derived from the value for zoom levels used in OpenStreetMap tile schema. OpenStreetMap uses the EPSG:3857 coordinate system (called SphericMercator within Mapsui). The full width of that coordinate system is 40075017 units. The top level tile in OpenStreetMap is 256x256 pixels. So the top level tile has a resolution of 40075017 / 256 = 156543 if it is shown unscaled.</p>"},{"location":"resolution/#scale-in-meters-pixel-in-openstreetmap","title":"Scale in meters / pixel in OpenStreetMap","text":"<p>The coordinates of EPSG:3857 happen to be based on the circumference of the earth in meters at the equator which is 40075017 meters. This means that near the equator the units of EPSG:3857 are equal to meters. It starts to deviate when moving away from the equator. Also note that other coordinate systems can have completely different unit sizes. So the relation between the coordinate system used and meters is complicated.</p>"},{"location":"resolution/#i-am-just-interested-in-meters-pixel-and-dont-care-about-the-coordinate-system","title":"I am just interested in meters / pixel and don't care about the coordinate system","text":"<p>That makes sense but at the moment there is no good solution for that in Mapsui. What makes this complicated:</p> <ul> <li>The meters / pixel can be different in the x and y direction because of distortion of the map projection.</li> <li>The meters / pixel can be different for different locations within a single map view.</li> <li>To implement this for a coordinate system we need projection support for that coordinate system, which we may not have. </li> </ul>"},{"location":"resolution/#density-independent-pixels","title":"Density Independent Pixels","text":"<p>When we talk about pixels on this page we mean density independent pixels, or dip, or dp.</p> <p>Modern devices have a very high resolution. If something is drawn onto the canvas using raw pixels as coordinates the fonts would become tiny and unreadable and lines would become very thin. To correct for this a scale factor is used. Those scaled-up coordinates are called density independent pixels. Most of the time users deal only with the density independent pixels.</p>"},{"location":"resolution/#density-independent-pixels-in-skiasharp","title":"Density Independent Pixels in SkiaSharp","text":"<p>The scale in skia has caused some confusion in the past and bugs as a consequence. So here is some extra information on this topic. This is mainly targeted at contributors, users of the Mapsui nugets do not need to know about this.</p> <p>Most (all?) views in SkiaSharp use pixels as coordinates by default but for our purposes we need to use density independent pixels, so we need to correct for this. We do this by setting the scale of skia's SKCanvas. This needs to be done in the render loop because it is the only place where we have access to the SKCanvas. Also the size of the map needs to be adjusted at that point, otherwise we would draw outside the screen. In later versions of SkiaSharp it is possible to use IgnorePixelScaling=true instead of scaling.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":"<p>Updated January 2024</p>"},{"location":"roadmap/#mapsui-4","title":"Mapsui 4","text":"<p>Branch: develop/4.1. Milestone: v4.1. Mapsui v4.1.x is the stable version you should use.</p> <ul> <li> Use NTS for geometries</li> <li> License to MIT</li> <li> Improve Viewport logic</li> <li> Improve MVVM support #1731</li> <li> Improve samples</li> <li> Add MAUI MapControl</li> <li> Add Blazor MapControl</li> <li> Add Uno Platform MapControl</li> <li> Add Avalonia MapControl</li> <li> Add Eto MapControl</li> <li> Add 'getting started' tutorials for all platforms</li> <li> Keep fixing bugs</li> </ul>"},{"location":"roadmap/#mapsui-5","title":"Mapsui 5","text":"<p>Branch: main. Milestone: v5.0. We are working on a series of preview releases.</p> <p>Focus: More shared code in platforms. This will affect MapControls, Widgets and manipulation (touch and mouse). The underlying objective is to make the development process faster by removing everything that slows us down. </p> <ul> <li> Lowest supported version to .NET 6 (remove .netstandard)</li> <li> All samples and tests to .NET 8.</li> <li> Cleanup:<ul> <li> Rename master to main.</li> <li> Run dotnet format on the entire solution.</li> <li> Run dotnet style on the entire solution.</li> <li> Run dotnet analyze on the entire solution.</li> <li> Always propagate async back to the caller.</li> <li> Remove nuget packages that we previously needed for things now supported in .NET 6.</li> <li> Remove code copies of things now in .NET 6 (in the past we copied some .NET Core things which were not in .NET standard).</li> <li> Remove the #if defines we do not need anymore.</li> <li> Remove all scripts and configurations we do not use anymore.</li> <li> Simplify the build scripts now that we do not need the workarounds.</li> <li> Use <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> everywhere (Add to Directory.Build.props) and revisit all current suppressions.</li> </ul> </li> <li> Remove older frameworks:<ul> <li> Remove Xamarin.Forms (but not Mapsui.MAUI, Mapsui.iOS and Mapsui.Android).</li> <li> Remove Uno UWP (but not Mapsui.Uno.WinUI)</li> <li> Remove Avalonia.V0 (but not Avalonia)</li> </ul> </li> <li> Merge MapView functionality into MapControl. We need to work this out in more detail.<ul> <li> Add extension methods for Map to make it easy to add MapView functionality to the MapControl. A few:<ul> <li> AddMarkerLayer() extension which adds a layer with symbols and a callout style, which is toggled on click.</li> <li> AddOpenStreetMapBackgroundLayer() which adds to a specific layer group and sets the Map CRS and perhaps more.</li> </ul> </li> <li> Make MyLocationLayer function property in Mapcontrol.</li> <li> Add mechanism for layer grouping. Here is a proposal but perhaps we need something simpler.</li> </ul> </li> <li> Make Map dispose a layer when create function is used https://github.com/Mapsui/Mapsui/issues/2284.</li> <li> All fetching through a single pipeline https://github.com/Mapsui/Mapsui/issues/2269</li> </ul> <p>Not (yet) done:</p> <ul> <li> Dispose the samples if needed: https://github.com/Mapsui/Mapsui/issues/2254</li> <li> Fix the remaining warnings wrt IDispose.</li> </ul>"},{"location":"roadmap/#mapsui-6-options","title":"Mapsui 6 options:","text":"<ul> <li> Two step rendering. In the draw loop only draw skia object, create skia object in an earlier step https://github.com/Mapsui/Mapsui/issues/1448</li> <li> World wrap https://github.com/Mapsui/Mapsui/issues/518</li> <li> Add vector tiles https://github.com/Mapsui/Mapsui/issues/1478</li> <li> Blazor server side 'rendering' https://github.com/Mapsui/Mapsui/issues/3119</li> <li> Centralized projections: https://github.com/Mapsui/Mapsui/issues/3122</li> <li> Add support for GeoParquet https://github.com/Mapsui/Mapsui/issues/2282</li> <li> Let Map be Disposable but not the MapControl https://github.com/Mapsui/Mapsui/issues/2703</li> <li> For possible other options you could  browse through the 'design discussion' tags .</li> </ul>"},{"location":"samples/","title":"Samples","text":""},{"location":"samples/#samples","title":"Samples","text":"<p>After going through the quickstart you should look into the samples. All samples work the same on all platforms. You can view online samples presented in Blazor here. Each sample has an accompanying 'source code' tab you can use to build your own version. </p>"},{"location":"samples/#download-samples-if-you-have-to","title":"Download samples if you have to","text":"<p>Currently the source code of the samples does not always contain all needed code. In that case you may need to clone the project and open the .slnf of your favorite UI framework. Then set Mapsui.Samples.'YourFavorityUIFramework'.csproj as startup project. If you run any of the samples you will see there is a way to select a category and within that category several specific samples. All these samples correspond to a specific sample class that is derived from ISample (or IMapControlSample). The most easy way to find them is to search for the name of the sample that is displayed including quotes. For instance, searching for <code>\"Points\"</code> will lead you to the file PointsSample.cs. </p>"},{"location":"touch-and-mouse-handling/","title":"Touch and mouse handling","text":""},{"location":"touch-and-mouse-handling/#touch-and-mouse-handling","title":"Touch and mouse handling","text":"<p>In Mapsui v5 (at the moment of writing this is beta.1) most of the touch and mouse handling code is now shared over UI frameworks. There are a lot of differences between the frameworks so we need some non-shared code but we try to map it early to shared methods and components.</p>"},{"location":"touch-and-mouse-handling/#widget-event-types","title":"Widget Event types","text":"<p>In v5 beta.1 we have four new event types:</p> <ul> <li>PointerPressed (down)</li> <li>PointerMoved (can be hover for mouse)</li> <li>PointerReleased (up)</li> <li>Tapped. This can be single tap, double tap or long press.</li> </ul> <p>The names were taken from Uno/WinUI and Avalonia. Perhaps we will need other pointer event types in the future. We still have the Info event type, but this could now be replaced by the other event types because they also can be used to get the MapInfo through a WidgetEventArgs.GetMapInfo() call.</p>"},{"location":"touch-and-mouse-handling/#components","title":"Components","text":"<ul> <li>ManipulationTracker: This component is called from the MapControl with an array of pointer positions (could be mouse or touch, or multitouch) and based on that calculates a new manipulation state (translate, scale, rotate). It is used for both drag and pinch, the difference being that while dragging the scale and rotate fields will have neutral values. The ManipulationTracker is also responsible for rotation snapping (snap out of rotation lock only when the rotation is bigger than some theshold, and snap back in when rotation is close to zero). Rotation snap was previously implemented on only a few platforms.</li> <li>TapTracker: This component detects a tap, a double tap and a long press. Previously there were many differences in how this was implemented.</li> <li>FlingTracker: This is an old component that was previously used on just two UI frameworks and is now used on all.</li> </ul>"},{"location":"touch-and-mouse-handling/#testing-touch-and-mouse-handling","title":"Testing touch and mouse handling","text":"<p>Testing is hard. In v5 we support nine different UI frameworks and a single framework can run on different devices/platforms, like Windows, Mac, Linux, Android, iOS and WASM. With hard work you could test those once, but we are continuously making changes, and it is impossible to test all those UI frameworks on every change. You could help us by testing your own favorite UI framework. Below is checklist we used on some occasions. We are open to suggestions to expand the list:</p>"},{"location":"touch-and-mouse-handling/#touch-test-checklist-for-our-samples","title":"Touch test checklist for our samples:","text":"<ul> <li> In Widgets|Button: Tap on 'Tap me' button goes up by one.</li> <li> In Widgets|Button: Pressed next to widget, move above the widget and release there. The widget should not change the tap count.</li> <li> In Widgets|Button: Pressed on the widget, move next to the widget and release there. The widget should not change the tap count.</li> <li> In Widgets|Button: Double Tap should increase the tap count by one.</li> <li> In Widgets|Hyperlink: Tap on hyperlink should open a browser page.</li> <li> In Demo|MapInfo: MapInfo should show on the bottom left in the map.</li> <li> In Info|SingleCallout: Callout should show on tap on symbol, should disappear on a second tap on either symbol or callout.</li> <li> In Info|CustomCallout: Callout should not toggle the callout but only show info bottom left.</li> <li> In Widgets|PerformanceWidget: Tap on widget should reset the values in the widget.</li> <li> In Widgets|MouseCoordinatesWidget: The mouse coordinates should change while hovering.</li> <li> In Widgets|ZoomInOutWidget: Tap on the plus and min buttons should zoom in and out.</li> <li> In Widgets|TextBox: A mouse down or up should trigger nothing.</li> <li> In Editing|Modify: Dragging on the polygon should move the polygon not the map.</li> <li> In Editing|Rotate: Dragging on the polygon should rotate the polygon not the map.</li> <li> In Editing|Scale: Dragging on the polygon should scale the polygon not the map.</li> <li> In Editing|Modify: Add vertices to the polygon by tapping inside the polygon near the line.</li> <li> In Editing|Modify: Delete vertices by a double tap or long press on that vertex. Shift can also be used but is only implemented on a few UI frameworks. </li> </ul>"},{"location":"v4.0-upgrade-guide/","title":"v4.0 Upgrade Guide","text":""},{"location":"v4.0-upgrade-guide/#v40-upgrade-guide","title":"v4.0 Upgrade Guide","text":""},{"location":"v4.0-upgrade-guide/#nuget-organization-changes","title":"Nuget organization changes","text":"<p>The Mapsui core package has been split up into:</p> <ul> <li>Mapsui.</li> <li>Mapsui.Tiling, which has a dependency on BruTile. It contains everything related to the raster tiles, like the TileLayer.</li> <li>Mapsui.Nts, which has a dependency on NetTopologySuite (NTS). It replaces everything that was in Mapsui.Geometries.</li> <li>Mapsui.Rendering.Skia.</li> </ul>"},{"location":"v4.0-upgrade-guide/#other-changes","title":"Other changes","text":"<ul> <li>Namespaces have changed following the nuget changes.</li> <li>Where you used Mapsui.Geometries you should now use Mapsui.Nts. The geometries themselve have been replaced by NTS.</li> <li>Mapsui.Geometries project has been removed, and replaced with NTS geometries.</li> <li>Mapsui.Geometries.Point was replaced by Mapsui.MPoint </li> <li>Mapsui.Geometries.BoundingBox was replaced by Mapsui.MRect.</li> <li>Mapsui.Projection moved to Mapsui.Projections.</li> <li>Mapsui.Rendering.Skia.CalloutType moved to Mapsui.Styles.CalloutType.</li> <li>Feature was replaced by: PointFeature or GeometryFeature or RectFeature or RasterFeature.</li> <li>The Features collection was removed and replace by and an <code>IEnumerable&lt;IFeature&gt;</code> (could be a List or Array).</li> <li>A RasterFeature now needs a RasterStyle or it will not be visible.</li> <li>The Viewport class was replaced with an immutable record. Many methods that were previously in Viewport are now in Navigator or Viewport.Extensions.</li> <li>MapControl.Navigator moved to MapControl.Map.Navigator.</li> <li>MapControl.Viewport moved to MapControl.Map.Navigator.Viewport</li> <li>INavigator was removed use Navigator instead.</li> <li>The Navigator.NavigateTo overloads were replaced with several methods with more descriptive names, like ZoomToBox.</li> </ul>"},{"location":"v5.0-upgrade-guide/","title":"v5.0 Upgrade Guide","text":""},{"location":"v5.0-upgrade-guide/#v50-upgrade-guide","title":"v5.0 Upgrade Guide","text":""},{"location":"v5.0-upgrade-guide/#by-compile-error","title":"By compile error","text":"<p>Below is a list of compile error that you could encounter when upgrading van Mapsui V4 to V5. Please inform us if you run into compile errors that are not in this list.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-layer-does-not-contain-a-definition-for-ismapinfolayer","title":"Compile error: 'Layer' does not contain a definition for 'IsMapInfoLayer'","text":"<p>The <code>IsMapInfoLayer</code> field was deprecated. The caller is now responsible for which layers should be queried by passing the list of layers as argument to the GetMapInfo call. The GetMapInfo method is available on the EventArgs of all pointer events. Here is the documentation on MapInfo. </p>"},{"location":"v5.0-upgrade-guide/#straightforward-port-of-ismapinfolayer","title":"Straightforward port of IsMapInfoLayer","text":"<p>There are many ways to specify which layers to query, but if you are already using IsMapInfoLayer in v4 then you could use this straightforward port. The idea is to store the IsMapInfoField inside an object in the ILayer.Tag field. </p> <p>Create a new class with an IsMapInfoLayer field:</p> <pre><code>public class LayerData\n{\n    public bool IsMapInfoLayer { get; set; }\n}\n</code></pre> <p>Assign an instance to the ILayer.Tag field when you create the layer: </p><pre><code>var layer = new Layer(layerName) { Tag = new LayerData { IsMapInfoLayer = true }};\n</code></pre><p></p> <p>Use that IsMapInfoLayer field to filter the e.Map.Layers in the GetMapInfo call: </p><pre><code>private void MapTapped(object? s, MapEventArgs e)\n{\n    var mapInfo = e.GetMapInfo(e.Map.Layers.Where(l =&gt; l.Tag is LayerData { IsMapInfoLayer: true }));\n}\n</code></pre><p></p>"},{"location":"v5.0-upgrade-guide/#compile-error-map-does-not-contain-a-definition-for-home","title":"Compile error: 'Map' does not contain a definition for 'Home'","text":"<p>In V5 you can call the Navigator methods to specify the startup view, for instance: <code>Map.Navigator.ZoomToBox(startupBox)</code>. The Home method solved a problem where you could not use the Navigator when the Map size was not initialized. In V5 this problem is solved within the Navigator by postponing the call until it is initialized.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-the-type-or-namespace-name-rectfeature-could-not-be-found","title":"Compile error: The type or namespace name 'RectFeature' could not be found","text":"<p>RectFeature was removed to simplify our code. Use <code>new GeometryFeature(myRect.ToPolygon())</code> instead.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-symbolstyle-does-not-contain-a-definition-for-bitmapid","title":"Compile error: 'SymbolStyle' does not contain a definition for 'BitmapId'","text":"<p>In V4 you had to register a bitmap and then assign the id to the SymbolStyle. In V5 you can directly specifify the path to the image source. See is the documentation on ImageSource</p>"},{"location":"v5.0-upgrade-guide/#compile-error-the-name-bitmapregistry-does-not-exist-in-the-current-context","title":"Compile error: The name 'BitmapRegistry' does not exist in the current context","text":"<p>See the item above.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-mapcontrol-does-not-contain-a-definition-for-screenwidth-and-no-accessible-extension-method-screenwidth-accepting-a-first-argument-of-type-mapcontrol-could-be-found","title":"Compile error: 'MapControl' does not contain a definition for 'ScreenWidth' and no accessible extension method 'ScreenWidth' accepting a first argument of type 'MapControl' could be found","text":"<p>Use <code>MapControl.Map.Navigator.Viewport.Width</code> instead.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-mapcontrol-does-not-contain-a-definition-for-screenheight-and-no-accessible-extension-method-screenheight-accepting-a-first-argument-of-type-mapcontrol-could-be-found","title":"Compile error: 'MapControl' does not contain a definition for 'ScreenHeight' and no accessible extension method 'ScreenHeight' accepting a first argument of type 'MapControl' could be found","text":"<p>Use <code>MapControl.Map.Navigator.Viewport.Height</code> instead.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-irenderer-is-obsolete-use-imaprenderer-instead","title":"Compile error: 'IRenderer' is obsolete: 'Use IMapRenderer instead'","text":"<p>Use IMapRenderer where you used IRenderer before.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-imaprenderer-does-not-contain-a-definition-for-stylerenderers-and-no-accessible-extension-method-stylerenderers-accepting-a-first-argument-of-type-irenderer-could-be-found","title":"Compile error: 'IMapRenderer' does not contain a definition for 'StyleRenderers' and no accessible extension method 'StyleRenderers' accepting a first argument of type 'IRenderer' could be found","text":"<p>Use the static <code>MapRenderer.RegisterStyleRenderer(...)</code> method for registering and the <code>mapControl.Renderer.TryGetStyleRenderer</code> method when drawing.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-imaprenderer-does-not-contain-a-definition-for-widgetrenders-and-no-accessible-extension-method-widgetrenders-accepting-a-first-argument-of-type-irenderer-could-be-found","title":"Compile error: 'IMapRenderer' does not contain a definition for 'WidgetRenders' and no accessible extension method 'WidgetRenders' accepting a first argument of type 'IRenderer' could be found","text":"<p>Use the static <code>MapRenderer.RegisterWidgetRenderer(...)</code> method for registering and the <code>mapControl.Renderer.TryGetWidgetRenderer</code> method when drawing.</p>"},{"location":"v5.0-upgrade-guide/#compile-error-mylayer-does-not-implement-interface-member-iasyncdatafetcherrefreshdatafetchinfo-actionfunctask","title":"Compile error: 'MyLayer' does not implement interface member 'IAsyncDataFetcher.RefreshData(FetchInfo, Action&lt;Func&lt;Task&gt;&gt;)'","text":"<p>Add the enqueueFetch action to you RefreshData interface like this:</p> <p><code>public void RefreshData(FetchInfo fetchInfo, Action&lt;Func&lt;Task&gt;&gt; enqueueFetch)</code></p> <p>You could ignore enqueueFetch or use it to let it handle your async data fetch. A better option is to implement <code>IFetchableSource</code> instead of <code>IAsyncDataFetcher</code>. <code>IFetchableSource</code> utilizes the V5 centralized fetcher.</p>"},{"location":"v5.0-upgrade-guide/#list-of-changes-in-the-order-that-they-were-applied","title":"List of changes in the order that they were applied.","text":"<ul> <li>Removed <code>RectFeature</code>. Instead of <code>new RectFeature(myRect)</code> use <code>new GeometryFeature(myRect.ToPolygon())</code></li> <li>Removed the existing events that were specific to the MAUI MapControl. Alternatives: Use the shared <code>MapControl</code> events: MapTapped, MapPointerPressed, MapPointerMoved, MapPointerReleased, or the events on the <code>Map</code>: Tapped, PointerPressed, PointerMoved, PointerReleased.</li> <li>Introduced PinchState to replace separate center, radius and angle fields and used in o.a. the Map.Navigator.Pinch method.</li> <li>Moved UnSnapRotationDegrees and UnSnapRotationDegrees properties from MapControl to MapControl.Map.Navigator.</li> <li>Rename Microsoft.Maui.Graphics.Color ToNative(this Styles.Color color) to ToMaui.</li> <li>Because BaseFeature is now derived from IFeature and the previously not-implemented methods and fields had to be defined as abstract, these now need the <code>override</code> keyword in the derived classes.</li> <li>The logic around MapInfo was rewritten. In V4 the Info event returned a MapInfo object which contained the features on the tap location for those layers for which IsMapInfoLayer was set to true. In V5 IsMapInfoLayer is removed. The Info event args do not contain a MapInfo object but a GetMapInfo method to retrieve it. That method needs a list of layers to query. There is also a GetRemoteMapInfo for layers that get the feature info from the server, like WMS.</li> </ul>"}]}