@namespace Mapsui.UI.Blazor;
@inject IJSRuntime JsRuntime
<div class="MapControl" onmouseup=@OnMouseUp onmousedown=@OnMouseDown onmousewheel=@OnMouseWheel onmousemove=@OnMouseMove>
    <SKGLView name="_skglView" OnPaintSurface=@OnPaintSurface IgnorePixelScaling="true" EnableRenderLoop="true" />
</div>
@code 
{
    private RectangleF? _selectRectangle;
    private PointF? _downMousePosition;
    private double? _lastY;
    private string _defaultCursor = Cursors.Default;
    public string MoveCursor { get; set; } = Cursors.Move;
    public int MoveButton { get; set; } = MouseButtons.Primary;
    public int MoveModifier { get; set; } = Keys.None;
    public int ZoomButton { get; set; } = MouseButtons.Primary;
    public int ZoomModifier { get; set; } = Keys.Control;
    public MouseWheelAnimation MouseWheelAnimation { get; } = new();

    // Alternative: protected override void OnInitialized()    
    public MapControl()
    {
        CommonInitialize();
        ControlInitialize();
    }

    void OnPaintSurface(SKPaintGLSurfaceEventArgs e)
    {
        // the the canvas and properties
        var canvas = e.Surface.Canvas;
        _canvasSize = e.Info;

        // On Loaded Workaround
        if (!_onloaded)
        {
            _onloaded = true;
            OnLoadComplete();
        }
        
        // Size changed Workaround
        if (_canvasSize?.Width != e.Info.Width || _canvasSize?.Height != e.Info.Height)
        {
            _canvasSize = e.Info;
            OnSizeChanged();    
        }
        
        CommonDrawControl(canvas);
    }

    private void ControlInitialize()
    {
        _invalidate = () => { }; // Currently it is continuously invalided by Blazor (Render Loop)

        // Mapsui.Rendering.Skia use Mapsui.Nts where GetDbaseLanguageDriver need encoding providers
        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

        Renderer = new MapRenderer();
        RefreshGraphics();
    }

    private void OnLoadComplete()
    {
        SetViewportSize();
    }
    
    private void OnMouseWheel(MouseEventArgs e)
    {
        if (_map?.ZoomLock ?? true) return;
        if (!Viewport.HasSize) return;

        if (_lastY != null)
        {
            var delta = e.PageY - _lastY.Value;
            var resolution = MouseWheelAnimation.GetResolution((int)delta, _viewport, _map);
            // Limit target resolution before animation to avoid an animation that is stuck on the max resolution, which would cause a needless delay
            resolution = _map.Limiter.LimitResolution(resolution, Viewport.Width, Viewport.Height, _map.Resolutions, _map.Extent);
            var location = new MPoint(e.PageX, e.PageY);
            Navigator?.ZoomTo(resolution, location, MouseWheelAnimation.Duration, MouseWheelAnimation.Easing);
        }
        
        _lastY = e.PageY;
    }
    
    private void OnSizeChanged()
    {
        SetViewportSize();
    }
    
    private void RunOnUIThread(Action action)
    {
        // Only one thread is active in WebAssembly.
        action();
    }
    
    private void OnMouseDown(MouseEventArgs e)
    {
        IsInBoxZoomMode = e.Buttons == ZoomButton && (ZoomModifier == Keys.None || e.Modifiers == ZoomModifier);

        bool move_mode = e.Buttons == MoveButton && (MoveModifier == Keys.None || e.Modifiers == MoveModifier);

        if (move_mode)
            _defaultCursor = Cursor;

        if (move_mode || IsInBoxZoomMode)
            _downMousePosition = e.Location;
    }
    
    private bool IsInBoxZoomMode
    {
        get => Content.Visible;
        set
        {
            _selectRectangle = RectangleF.Empty;
            Content.Visible = value;
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        if (IsInBoxZoomMode)
        {
            var previous = Viewport.ScreenToWorld(_selectRectangle.TopLeft.X, _selectRectangle.TopLeft.Y);
            var current = Viewport.ScreenToWorld(_selectRectangle.BottomRight.X, _selectRectangle.BottomRight.Y);
            ZoomToBox(previous, current);
        }
        else if (_downMousePosition.HasValue)
        {
            if (IsClick(e.Location, _downMousePosition.Value))
                OnInfo(InvokeInfo(e.Location.ToMapsui(), _downMousePosition.Value.ToMapsui(), 1));
        }

        _downMousePosition = null;

        Cursor = _defaultCursor;

        RefreshData();
    }
    private static bool IsClick(PointF currentPosition, PointF previousPosition)
    {
        return Math.Abs(PointF.Distance(currentPosition, previousPosition)) < 5;
    }
   
    private void OnMouseMove(MouseEventArgs e)
    {
        if (_downMousePosition.HasValue)
        {
            if (IsInBoxZoomMode)
            {
                _selectRectangle.TopLeft = PointF.Min(e.Location, _downMousePosition.Value);
                _selectRectangle.BottomRight = PointF.Max(e.Location, _downMousePosition.Value);
                Content.Invalidate();
            }
            else // drag/pan - mode
            {
                Cursor = MoveCursor;

                _viewport.Transform(e.Location.ToMapsui(), _downMousePosition.Value.ToMapsui());

                RefreshGraphics();

                _downMousePosition = e.Location;
            }
        }
    }
    
    public void ZoomToBox(MPoint beginPoint, MPoint endPoint)
    {
        var width = Math.Abs(endPoint.X - beginPoint.X);
        var height = Math.Abs(endPoint.Y - beginPoint.Y);
        if (width <= 0) return;
        if (height <= 0) return;

        ZoomHelper.ZoomToBoudingbox(beginPoint.X, beginPoint.Y, endPoint.X, endPoint.Y,
            ViewportWidth, ViewportHeight, out var x, out var y, out var resolution);

        Navigator?.NavigateTo(new MPoint(x, y), resolution, 384);

        RefreshData();
        RefreshGraphics();
        ClearBBoxDrawing();
    }
    
    private void ClearBBoxDrawing()
    {
        RunOnUIThread(() => IsInBoxZoomMode = false);
    }

    private float GetPixelDensity()
    {
        return 1;
        // TODO: Ask for the Real Pixel size.
        // var center = PointToScreen(Location + Size / 2);
        // return Screen.FromPoint(center).LogicalPixelSize;
    }   
}