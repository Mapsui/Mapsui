{
  "documentation/Roadmap.html": {
    "href": "documentation/Roadmap.html",
    "title": "Roadmap start 2019",
    "keywords": "Roadmap start 2019 Getting v2 more stable. Improve the documentation. Adding 'getting started' tutorials for all platforms. Show all samples in the iOS and Android projects. Improve the samples. Add comments, make them smaller (single purpose) and make them look better. Later Replace Mapsui.Geometries with NTS Add vector tiles Improve performance Change license to MIT"
  },
  "documentation/Rendering-Tests.html": {
    "href": "documentation/Rendering-Tests.html",
    "title": "Unit Tests for Rendering",
    "keywords": "Unit Tests for Rendering Testing the renderers in done in two ways. Unit tests that compare the current output to previous output. Visual inspection. Unit tests are useful during refactoring when you expect no changes. Visual tests are useful when you are working on a change in the rendering output. 1. Unit tests The generated images are written to: {test project folder}\\bin\\Debug\\Resources\\Images\\Generated\\ Those will be compared to the original images in: {test project folder}\\bin\\Debug\\Resources\\Images\\Original\\ If after code changes there are expected changes in the generated files they should be committed to git so they need to be copied to: {test project folder}\\Resources\\Images\\Original\\ 2. Visual inspection In the WPF sample there is an option to select the list of unit tests. Both WPF and Skia renderers can be selected. We assume the skia renderer on other platforms are identical."
  },
  "documentation/How-to-work-with-Mapsui.html": {
    "href": "documentation/How-to-work-with-Mapsui.html",
    "title": "How to Work with Mapsui",
    "keywords": "How to Work with Mapsui Mapsui is growing towards a stable component. At all times: All projects should compile The unit tests should succeed All samples should run properly If this is not the case please report it. It will be fixed. Please use the nuget packages to build applications with Mapsui: Install-Package Mapsui Extension of Mapsui If you need more functionality from the MapControl you could create your own version of the MapControl by making a copy. You can customize these for your own needs. While it is also possible to extend functionality by adding your own ILayer or IProvider implementation. If you encounter breaking changes please take a look at the release notes . You can check the related commits by clicking the 'x commits to masters since this release' of the previous release (a bit odd but that is how github works). Logging In Mapsui errors and warnings are logged to one static class. By listening to this with an event handler you can get some debugging information. .. // Logger is a static class that can be accessed when you add the Mapsui core dll. Logger.LogDelegate += LogMethod; .. private void LogMethod(LogLevel logLevel, string message, Exception exception) { // todo: write to your own logger }"
  },
  "documentation/Development-constraints.html": {
    "href": "documentation/Development-constraints.html",
    "title": "Development constraints",
    "keywords": "Development constraints When developing for Mapsui we take into account the following constraints. Not limited to certain coordinate system Mapsui's Map can be in any coordinate system. If you do not specify a coordinate system in the Map and Layers it assumes they are in the same coordinate system (whatever they are). In this case it only transforms these unspecified 'world-coordinates' to 'screen-coordinates' and nothing more. It is also possible to setup a coordinate transformation system using Map.CRS, DataSource.CRS and Map.Transformation. See projections . Full implementation of the feature matrix These are some of the feature dimensions: Renderers: WPF and Skia Geometries: Point, LineString, Polygon etc. Operations on Geometries: Distance, Contains. Coordinate projection support Style: fill color, line color, line cap, symbol opacity, symbol scale If we choose to support a feature each 'cell' of the multi dimensional matrix should be supported. No surprises for the user. Currently there are holes in the matrix on some point (like differences between WPF and Skia). The current focus is to fill these holes. If this support does not seem attainable (is that proper English?) but does seem very useful we should look for ways to make Mapsui extendable Write clear, simple and little code Maintenance is enemy that can bring a project like this to a halt. We should look for ways to implement the functionality with the simplest possible code."
  },
  "index.html": {
    "href": "index.html",
    "title": "Mapsui documentation.",
    "keywords": "Mapsui documentation. The Mapsui documentation consists of two parts. The general documentation found here . The api documentation found here . Sponsors We are delightly with our first gold sponsor Sebastian Kruze, who has also contributed to Mapsui with informed test reports and expert advice. Sebastian Kruze"
  },
  "documentation/Mapsui.Forms.html": {
    "href": "documentation/Mapsui.Forms.html",
    "title": "Mapsui.Forms",
    "keywords": "Mapsui.Forms Mapsui.Forms is a Xamarin.Forms native library for Mapsui. With this library it is possible to use Mapsui without any renderer. Mapsui.Forms uses SkaiSharp.Views.Forms to display the map on the device. This works for iOS, Android, UWP and Mac OS. WPF should be possible too, but isn't tested. Installation Create a normal Xamarin.Forms project Add Mapsui.Forms from NuGet to the packages Add the line xmlns:mapsui=\"clr-namespace:Mapsui.UI.Forms;assembly=Mapsui.UI.Forms\" to the Xaml file Add the Mapsui.Forms view with <mapsui:MapView x:Name=\"mapView\" VerticalOptions=\"FillAndExpand\" HorizontalOptions=\"Fill\" BackgroundColor=\"Gray\" /> to the Xaml part file Add in the code behind the following ```` var map = new Map { CRS = \"EPSG:3857\", Transformation = new MinimalTransformation() }; var attribution = new BruTile.Attribution(\"Â© OpenStreetMap contributors\", \" http://www.openstreetmap.org/copyright \"); var tileSource = new HttpTileSource(new GlobalSphericalMercator(), \"http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", new[] { \"a\", \"b\", \"c\" }, name: \"OpenStreetMap\", attribution: attribution); var tileLayer = new TileLayer(tileSource) { Name = \"OpenStreetMap\" }; map.Layers.Add(tileLayer); map.Widgets.Add(new Widgets.ScaleBar.ScaleBarWidget(map) { TextAlignment = Widgets.Alignment.Center, HorizontalAlignment = Widgets.HorizontalAlignment.Left, VerticalAlignment = Widgets.VerticalAlignment.Bottom }); mapView.Map = map; 6. Now you are ready to run a test"
  },
  "documentation/Mapsui-2.0.html": {
    "href": "documentation/Mapsui-2.0.html",
    "title": "Mapsui 2.0",
    "keywords": "Mapsui 2.0 At the moment we are working on Mapsui v2. The core libraries are .NET Standard instead of PCLs. Here are some of the changes that may go into v2. Todo Testing. Some possible rework following from user feedback. Done Do not derive ILayer from IAsyncDataFetcher. Add an Action field to the Map to zoom to 'home' viewport. Remove Viewport from Map. Remove Navigate methods from Map. Go to .NET Standard Rename Map.ViewChanged to Map.RefreshData Remove WPFs MapControl.ErrorMessage Rename PanMode.None and ZoomMode.None. Rename BoundingBox.GetCentroid to Centroid Rename IGeometry.GetBoundingBox to BoundingBox Move Info event from Map to MapControl Remove the InfoLayer list and add an InfoLayer boolean on ILayer Remove the HoverLayer method. It is not crossplatform and can affect performance. Invert label alignment bottom/top. Remove ZoomIn/ZoomOut from WPF MapControl and turn into Navigate method. Wrap Viewport in LimitingViewport which limits it to user settings, or access through Navigator. PanLock and ZoomLock working on all platforms. Rework ViewportLimiter Add Xamarin.Forms MapControl Not (Later) Use NTS for Geometries Perhaps add animation in an AnimatedViewport which wraps the actual Viewport. Replace ILayer.Style with an ILayer.Styles of type ICollection which is empty by default"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Mapsui API",
    "keywords": "Mapsui API This is the API description of Mapsui"
  },
  "documentation/v2.0-upgrade-guide.html": {
    "href": "documentation/v2.0-upgrade-guide.html",
    "title": "v2.0 upgrade guide",
    "keywords": "v2.0 upgrade guide This is the incomplete upgrade guide from v1.4 to v2.0. The most apparent changes will be mentioned here. If you notice important things missing then please post an issue. Moved from PCL to .NET Standard 2.0 Look up compatible frameworks in this table . Viewport moved from Map to MapControl and is readonly Use MapControl.Navigator instead. Moved MapControl.NavigateTo methods to MapControl.Navigator All user map manipulation should go the the Navigator. Introduced Map.Home to initialze the map viewport There is now a Home delegate on the Map object that should be used to set the initial state of the map. MapControl.Map.Home = n => n.NavigateTo(myCenter, myResolution); Reason: This is because in some cases the Navigate methods depend on the envelope and resolutions of the layers and in some cases it takes time for these layers to load their data. Added Map.PanLock, Map.ZoomLock and Map.RotationLock The lock fields can be used on all platforms to lock the user from a certain kind of map manipulation. Added Map.Limiter to limit the extent to which the user can navigate The Limter is an implementation of IViewportLimiter. There are currently three limiters part of Mapsui: ViewportLimiter (default) ViewportLimiterKeepWithin ViewportLimiterWithoutLimits It is also possible to implement your own IViewportLimiter. Added RefreshGraphics, RefreshData and Refresh Use RefreshGraphics if you know the data in the layer has changed and the graphics needs refreshing. Use RefreshData if you know there is new data available in the source. Use Refresh if you need to do both. These methods should only be needed if you manipulate data somehow in your own code. Renamed BoundingBox GetCentroid to Centroid and GetBoundingBox to BoundingBox Turned these methods into proper properties making user code a bit more compact. The Info event was moved from Map to MapControl The MapControl contains most other events as well Removed the InfoLayer list and add an InfoLayer boolean on ILayer To indicate that a layer is a info layer you now need to set it's InfoLayer property. In v1.4 it had to be added to the list of InfoLayers. Removed the HoverLayer method. This is because hover could not be implemented crossplatform and could harm performance. It it is still possible to implement hover yourself using a direct call to MapControl.GetMapInfo. Invert label alignment bottom/top. This was incorrect in v1.4. This will not cause a compile error so don't forget to do a search-replace to fix it. Removed ZoomIn/ZoomOut from WPF MapControl Use the ZoomIn/ZoomOut methode on the navigator."
  },
  "documentation/NuGet-of-latest-build.html": {
    "href": "documentation/NuGet-of-latest-build.html",
    "title": "NuGet of Latest Build",
    "keywords": "NuGet of Latest Build On every commit the build server is triggered which publishes a NuGet package of that build. It's version number is the current version of the master branch followed by a dot and the build number. The package is not published to nuget.org but to a AppVeyor feed. You need to add this feed to be able to install the package to your project. There are three ways to add this feed to your environment. Package Manager Console nuget install-package mapsui -source https://ci.appveyor.com/nuget/mapsui -pre Add the feed in Visual Studio Add the feed in tools | options | nuget | package sources https://ci.appveyor.com/nuget/mapsui And under 'manage nuget packages' select this as source on the top right. Add a .nuget\\NuGet.Config xml In you sln folder add a .nuget folder and in it a NuGet.Config file with content: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <solution> <add key=\"disableSourceControlIntegration\" value=\"true\" /> </solution> <packageSources> <add key=\"AppVeyor\" value=\"https://ci.appveyor.com/nuget/mapsui \" /> <add key=\"nuget.org\" value=\"https://www.nuget.org/api/v2/\" /> </packageSources> </configuration> This way you application knows where to find the package and when other developers clone your project it works for them too right away. This is the best option. Build your own nuget package It is also possible to build you own nuget package locally by running scripts\\buildpack.bat 1.0.0-beta.1 from the sln folder. You can set the file location as a Package Source in visual studio."
  },
  "documentation/Mapsui-Components.html": {
    "href": "documentation/Mapsui-Components.html",
    "title": "Mapsui Components",
    "keywords": "Mapsui Components If you install the NuGet package into your app these assemblies are added: Mapsui.UI.{platform} - Platform specific UI. Contains the MapControl Mapsui.Rendering.Skia Mapsui Mapsui.Geometries On Windows desktop Mapsui.Rendering.Xaml is added. A number of nuget dependencies Mapsui Parts There are three important classes that you will deal with MapControl This is the UI component that you add to you project. Map Holds all information about the map like layers and widgets. Viewport Holds all information about the part of the map that is visible on the screen like center, extent, rotation, resolution and so on. It is created automatically when Map is created. You can access it with MapControl.Map.Viewport."
  },
  "documentation/getting-started-wpf.html": {
    "href": "documentation/getting-started-wpf.html",
    "title": "Mapsui WPF getting started",
    "keywords": "Mapsui WPF getting started This page will show the steps to add a Mapsui map to your WPF application. Step 1 Start a new WPF application in Visual Studio. Step 2 In the package manager console type: PM> Install-Package Mapsui Step 3 In WpfApplication1.MainWindow.xaml add this in the Grid element: <xaml:MapControl Name=\"MyMapControl\"></xaml:MapControl> And add the namespace: xmlns:xaml=\"clr-namespace:Mapsui.UI.Wpf;assembly=Mapsui.UI.Wpf\" Step 4 In WpfApplication1.MainWindow.xaml.cs add in the constructor: MyMapControl.Map.Layers.Add(new TileLayer(KnownTileSources.Create())); And add the namespaces: using BruTile.Predefined; using Mapsui.Layers; Step 5 Run!"
  },
  "documentation/faq.html": {
    "href": "documentation/faq.html",
    "title": "Frequently Asked Questions",
    "keywords": "Frequently Asked Questions Why is all my data in a small area near the west coast of Africa? This is because the background data is in SphericalMercator (it is in the SphericalMercator coordinate system) and the foreground data is in WGS84 (latlon). Use SphericalMercator.FromLonLat to transform it. Note: There can be many other forms of mixing up coordinate systems, but this is the most common. Why does NavigateTo zoom into an area near the west coast of Africa? This is because the coordinates you pass to NavigateTo are in WGS84 whereas the background data is in SphericalMercator. Use SphericalMercator.FromLonLat to transform the NavigateTo arguments to SphericalMercator. Note: There can be many other forms of mixing up coordinate systems, but this is the most common."
  },
  "documentation/Async-Fetching.html": {
    "href": "documentation/Async-Fetching.html",
    "title": "Asynchronous Data Fetching",
    "keywords": "Asynchronous Data Fetching Some background In most mapping clients drawing a map means first gathering data from disk, database or web and after that a map is drawn. Because gathering data takes time the user has to wait for this process to complete. During this process sometimes a white map is shown and the user cannot interact with the map. This experience can be improved by drawing a buffer of the previous image during pan and zoom. But this results in white space along the edged. This can again be countered by other optimizations but there are limits to what can be done along this design path and it tends to lead to hacked up solutions. In Mapsui we completely seperated drawing from fetching data. The renderer only renders the data it has available in memory at that instant. The fetcher runs on a background thread receives messages from the UI thread telling it what to fetch. The async data fetcher architecture The diagram above shows how Mapsui's data fetcher works. The data fetcher runs on a background thread. The UI and Fetcher communicate through non blocking messages. Whenever the user pans or zooms a View Changed message is sent to the Fetcher. Whenever new data arrives a Data Changed message is sent to the UI so that it knows it should redraw the map. The fetcher dumps incoming data into a cache. The UI renderer retrieves whatever is needed from that cache when rendering. Both the fetcher and the renderer can use all kinds of smart tricks. In case of tiling the fetcher can preâfetch tiles based on its current view, or on the way the view changes over time. The renderer could search for alternative tiles (higher or lower levels) when the optimal tiles are not available. Those strategies should be tuned to support each other. For instance, in the current implementation the renderer uses higher level tiles when the optimal tiles are not available, and the fetcher preâfetches higher level tiles to assist the renderer. But the way they play together is not specified in the interface. This loose coupling keeps things simple and flexible and the renderer never has to wait for the fetcher which results in a smooth (perceived) performance."
  },
  "documentation/skia-scale.html": {
    "href": "documentation/skia-scale.html",
    "title": "Skia Scale",
    "keywords": "Skia Scale We have a separate page about this topic because skia scale has caused some confusion in the past and bugs as a consequence. Some context: Device Independent Units Modern devices have a very high resolution. If something is drawn onto the canvas using raw pixels as coordinates the fonts would become tiny and unreadable and lines would become very thin. To correct for this a scale factor is used. Those scaled-up coordinates are called device independent units. Most of the time you deal with the device independent units. Coordinates in SkiaSharp Most (all?) views in SkiaSharp use pixels as coordinates by default but for our purposes we need to use device independent units, so we need to correct for this. There are two ways this can be done: Set the skia view's IgnorePixelScaling. Call the skia view's Scale factor with the appropriate scale. For this you need to request the scale factor from the system. What do we do? We take skia scale into account on a number of places in our code: On WPF and UWP: We set IgnorePixelScaling. On iOS: The GL view we use has no IgnorePixelScaling unfortunately. We determine the skia scale while initializing (or when switching from wpf to skia rendering)ent's size changes. We set the skia scale on the skia surface. This needs to be done in the render loop because this is the only place where we have access to the surface. On Android: We determine the density (pixels per device independent units) while initializing. We initialze the viewport width and height to the skia width and height (on TryInitializeViewport). We set the viewport width and height to the skia width and height whenever the containing parent's size changes. We set the skia scale on the skia surface. This needs to be done in the render loop because this is the only place where we have access to the surface. We pass the skia scale along if we request map info. Why not directly correct the position for scale at the call? Because we want to return the original click position as part of the response. This position can be usefull and we don't want to user to correct for skia scale (in fact we don't want the user to have access to it). When requesting the touch positions when manipulating the map."
  },
  "documentation/samples.html": {
    "href": "documentation/samples.html",
    "title": "Samples",
    "keywords": "Samples The best way to get started with mapsui is to go through the samples. The code samples There are sample apps for each platform. They share a number of Map samples that can be found in this folder in our git repository Samples\\Mapsui\\Mapsui.Samples.Common\\Maps. For 2.0 look here For 1.4 look here Run the samples See the samples in action by running the WPF sample app ( Mapsui.Samples.Wpf ) in the samples folder. On the left side it has a list with all samples."
  },
  "documentation/Renderers.html": {
    "href": "documentation/Renderers.html",
    "title": "Renderers",
    "keywords": "Renderers Mapsui has two renderers: Xaml in the Mapsui.Rendering.Xaml assembly. Used only in the WPF MapControl. Older and stable. Skia in the Mapsui.Rendering.Skia assembly. Used in all supported platforms. Newer. Differences Between Xaml and Skia Skia is nearly equivalent to Xaml but there are still some differences (This list has grown shorter over last year): There is a difference in the way halo symbolization is implemented. We will match Xaml to Skia (not the other way around). We already use the correct technique for Xaml halos for labels styles. Skia does not have the option to displayed symbols in world units. The means the icon will grow bigger if you zoom in. This is unlike regular icon but like regular polgons. This is an exotic feature, you will probably not need this. There are probably some more differences I missed. Xaml and Skia side by side in Mapsui.Samples.Wpf The project Mapsui.Samples.Wpf has a dropdown on the top left to select between Skia and Wpf rendering. This is allows you to compare them."
  },
  "documentation/projections.html": {
    "href": "documentation/projections.html",
    "title": "Projections",
    "keywords": "Projections Projections is a complicated topic. Users of Mapsui have a wide variety of backgrounds. Some are experienced GIS users that just need to know how this specific map component works. Many others are app developers that just happen to need a map for their current app. This makes it hard to explain things clear for everyone. Below are some basic concepts. I like this video introduction to map projections. The most common scenario Much point data is in a coordinates system called WGS84, or lat/long coordinates, or EPSG:4326 . Most maps are in some another coordinate system which is better suited for display. The projection used in most online maps these days is SphericalMercator, or WebMercator, PseudoMercator or EPSG:3857 . The OpenStreetMap tile layer that is used in many samples of Mapsui is also in SphericalMercator. If you use this map your coordinates also need to be in SphericalMercator. By default there is no automatic projection in Mapsui. The Mapsui helper methods for this transformation are SphericalMerator.FromLonLat/ToLonLat. Parts of Mapsui involved in projections Map : There is one Map. It is inevitably in some kind of projection. Layers : There are several layers that provider data. This data should be in the same projection as the Map. If not, different projections will be drawn on top of each other and things go wrong. Providers : Some Layers have a DataSource (Provider). This DataSource could contain data in another projection. This data can be converted to the Map projection but a few things need to be set. Configure Mapsui for automatic projections Currently only the Layer layer type can be set up to do automatic projetions from DataSource to Map. Three things need to be configured for this: The CRS on the Map to know what to project to. The CRS on the DataSource to know what to project from. The Transformation on the Map to calculate the projection from DataSource CRS to the Map CRS. Support for projections The out of the box Mapsui support for projections is limited. The MinimalProjection class only projects between SphericalMercator (EPSG:3857) and WGS84 (EPSG:4326). It is however possible to create your own Transformation. You need to implement the ITransformation interface. Within this implementation you need to use some other projection library. A recommended one is ProjNet4GeoAPI . The most common scenario Most likely you will be fine if you use the same projection as Google and OpenStreetMap. This projection is called SphericalMercator. The official code from the OGC for this projection is EPSG:3857. If you use the OpenStreetMap background layer you use EPSG:3857. Often you have GPS locations or points of interests (POIs) in WGS84 or EPGS:4326. These points need to be transformed to EPSG:3857. There are two ways: Follow the configuration for projections mentioned above and in the ProjectionSample.cs. Use SphericalMercator.FromLonLat to do the transformation manually. Remarks A Layer has a CRS field. This field is used by Mapsui to set it to the Map projection. It should not be set by the user. This is could be confusing. Mapsui is not capable of transforming images. So no transformation of tiles as rasters. No attempt will be made to transform and the CRS fields will be ignored."
  },
  "documentation/Home.html": {
    "href": "documentation/Home.html",
    "title": "Introduction",
    "keywords": "Introduction Mapsui is a .NET component to show a map in your app. Supported platforms WPF UWP Xamarin.Android Xamarin.iOS Xamarin.Forms (in v2, now in beta) Supported data Mapsui uses the BruTile library to display tile layers such as: OpenStreetMap tiles Open standards for tiles WMTS TMS WMS called tilewise Custom data providers MBTiles. An offline format to store tile data in sqlite file. Mapsui renders and can style vector data (polygons, lines, points)"
  },
  "documentation/getting-started-android.html": {
    "href": "documentation/getting-started-android.html",
    "title": "Mapsui Android getting started",
    "keywords": "Mapsui Android getting started Step 1 Create 'Blank App (Android)' in Visual Studio Step 2 $ Install-Package Mapsui Step 3 In Resources/layout/Main.axml add Mapsui.UI.Android.MapControl: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> <Mapsui.UI.Android.MapControl android:id=\"@+id/mapcontrol\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /> </LinearLayout> Step 4 In MainActivity.cs add MapControl after SetContentView(Resource.Layout.Main): protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); // Set our view from the \"main\" layout resource SetContentView(Resource.Layout.Main); var mapControl = FindViewById<MapControl>(Resource.Id.mapcontrol); var map = new Map(); map.Layers.Add(OpenStreetMap.CreateTileLayer()); mapControl.Map = map; } Add the following using statements: using Mapsui; using Mapsui.Utilities; using Mapsui.UI.Android; Step 5: Run!"
  },
  "documentation/documentation.html": {
    "href": "documentation/documentation.html",
    "title": "Documentation",
    "keywords": "Documentation Documentation setup We use docfx to generate the documentation. There is a /docfx folder with a docfx project called Mapsui. This projects documenation folder contains all the md files used to generate the 'documentation' tab in the site. This is the source of those files, they should be edited there. In the docfx folder there is a script (build-site.cmd) that generates the documentation site (in /docfx/mapsui/_site) and copies it to the /docs folder. The Mapsui project on github is configured to automatically publish this docs folder to https://mapsui.github.io/mapsui A commit of an md file should trigger the build server. This should run the build-site.cmd. This should commit the generated site to the repo. It will when then show up on the website. We should have two separate build configurations one for the docs which ignores the project and one for the project which ignores the docs. Documentation guidelines All md files should be in lower case (they are not right now). All md files should be directly in the root of /docfx. Hierachy is created with the toc.md in the documenation folder. By keeping the files itself in the root it is easier to change the hierarchy and easier to get contributers to follow the guidelines. All md files should start with a header one (#) and have only one header one. All the headers in the toc should be equal to the header one in the file it points to. Mapsui is cased as Mapsui not MapsUI. We should iteratively improve the documentation. If questions are asked in the issues we should search for the answer in the documentation. Update the documentation when it is missing and answer the issue with a url to the documentation. Writing documentation is not only useful to inform the user but also as a sanity check for the developer. If what you have to tell becomes complicated and hard to grasp this could mean the software is not well designed. Writing documentation early should be used as a part of the software development process."
  },
  "documentation/Contributors-Guidelines.html": {
    "href": "documentation/Contributors-Guidelines.html",
    "title": "Mapsui Contributor Guidelines",
    "keywords": "Mapsui Contributor Guidelines CLA To contribute you need to sign our CLA Complexity Complexity is the biggest problem in software development. The primary effort should be to keep the complexity low. Complexity can be caused by clueless spaghetti code but also by astronaut architectures . Keeping things simple is not easy but hard work. It involves thinking up several solutions to your problem weighing the pros and cons and moving it around and upside down to look for even better (simpler) solutions. Continuous Refactoring Mapsui has some older code in it. Don't despair. We continuously improve or replace older code. It is a gradual process. We do it step by step. We have made major changes in the past; From WinForms to WPF, From GDI+ to SL rendering. From .NET Framework to PCL. From WPF rendering to SkiaSharp. We are working toward the next steps: From PCL to .NET Standard, support for full Xamarin.Forms. Taking these steps will cause breaking changes. We should be aware of this and clearly communicate it with the user. We should use semver (although we still violate it now and then). Issue first Submit an issue before a pull request co we can discuss the possible solutions to the problem. Use ReSharper Mapsui uses the resharper team settings by committing the DotSettings to git, so that all developers can use the same settings. We should have zero warnings. Suggestions should be treated as actual suggestions, use them only when you think it improves the code."
  }
}