{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Mapsui API",
    "keywords": "Mapsui API This is the API description of Mapsui"
  },
  "documentation/async-fetching.html": {
    "href": "documentation/async-fetching.html",
    "title": "Asynchronous Data Fetching",
    "keywords": "Asynchronous Data Fetching Some background To get smooth performance while panning and zooming data needs to be fetched on a background thread. Even if it is fetched on a background thread it will use resources which could be noticible in the responsiveness of the map. The asyncronous data fetching of Mapsui tries to take this into account to optimize the user experience. ChangeType (ChangeType was introduced in V3, in V2 the majorType boolean has this purpose) When calling the RefreshData method on the layers we pass in a ChangeType parameter which could be: Continous - During dragging, pinching zoom, or animations. Discrete - On zoom in/out button press, on touch up, or at the end of an animation. The layers itself decides how to respond to the refresh call. For different data types different strategies are used. TileLayer data fetching The diagram below shows how the TileLayers data fetcher works. The data fetcher runs on a background thread. The UI and Fetcher communicate through non blocking messages. Whenever the user pans or zooms a View Changed message is sent to the Fetcher. This will trigger the fetcher to start fetching data. Whenever new data arrives a Data Changed message is sent to the UI so that it knows it should redraw the map. The fetcher dumps incoming data into a cache. The UI renderer retrieves whatever is needed from that cache when rendering, not taking into account what the data fetcher is doing. This loose coupling keeps things simple and flexible and the renderer never has to wait for the fetcher which results in a smooth (perceived) performance. Read/Write cache For rendering the cache is only read. For data fetching the cache is primarily written but it is also needs to read the cache in order to know which data is already available and does not need to be fetched. Strategies Both the fetcher and the renderer can use some smart tricks to optimize the experience, for example: The fetcher can pre‐fetch tiles that are not directly needed but could be in the future. The renderer could search for alternative tiles (higher or lower levels) when the optimal tiles are not available. The implementation of these strategies can be overridden by the user by implementing interfaces that can be passed into the TileLayer constructor. The IDataFetchStrategy (IFetchStrategy in V2) determines which tiles are fetched from the data source to be stored in the cache. There is a DataFetchStrategy default implementation and a MinimalDataFetchStrategy which only fetches the tiles directly needed. The IRenderFetchStrategy (IRenderGetStrategy in V2) determines which tiles are fetched from the cache to use for rendering. There is a RenderFetchStrategy default implementation and a MinimalRenderFetchStrategy which only fetches the tiles directly needed. Those strategies should be tuned to support each other. For instance, in the current implementation the renderer uses higher level tiles when the optimal tiles are not available, and the fetcher pre‐fetches higher level tiles to assist the renderer. The way they play together is not specified in the interface so developers should take this into account. Data fetching in other layers Other layers like the Layer and ImageLayer have their own implementation. They use a delay mechanism in fetching new data and ignore ChangeType.Continuous."
  },
  "documentation/contributors-guidelines.html": {
    "href": "documentation/contributors-guidelines.html",
    "title": "Mapsui Contributor Guidelines",
    "keywords": "Mapsui Contributor Guidelines Issue first Submit an issue before a pull request so we can discuss the possible solutions to the problem. Sign the Contributor License Agreement (CLA) To contribute you need to sign our CLA Complexity Complexity is the biggest problem in software development. The primary effort should be to keep the complexity low. Complexity can be caused by clueless spaghetti code but also by astronaut architectures . Keeping things simple is not easy but hard work. It involves thinking up several solutions to your problem weighing the pros and cons and moving it around and upside down to look for even better (simpler) solutions. Continuous Refactoring Mapsui has some older code in it. Don't despair. We continuously improve or replace older code. It is a gradual process. We do it step by step. We have made major changes in the past; From WinForms to WPF, From GDI+ to SL rendering. From .NET Framework to PCL. From PCL to .NET Standard. From WPF rendering to SkiaSharp. Add support for Xamarin.Forms. Future changes will include moving to NTS geometries, improving the Layers list. Taking these steps will cause breaking changes. We are aware of this and clearly communicate it with the user. We use semver so breaking changes go in to major version upgrades. All checks should be green all the time At all times: All projects should compile The unit tests should succeed All samples should run properly Use ReSharper Mapsui uses the resharper team settings by committing the DotSettings to git, so that all developers can use the same settings. We should have zero warnings. Suggestions should be treated as actual suggestions, use them only when you think it improves the code. Keep dependencies in the csproj and nuspec in sync If we upgrade a nuget package in the solution we should also upgrade the lower bound of the nuget package in the nuspec because this is what nuget installs. We want the user to get the same version as the one that we are working and testing with. example csproj <PackageReference Include=\"SkiaSharp\" Version=\"2.80.2\" /> exmple nuspec <dependency id=\"SkiaSharp\" version=\"[2.80.2,3.0.0)\"/> Keep our direct and indirect dependencies in sync When we have direct and indirect dependecies on a nuget package those should all refer to the same version. For instance we have a direct dependency on SkiaSharp, but we also use SvgSkia and RichTextKit and those have a dependency on SkiaSharp too. It would be optimal if all referred to the same version of SkiaSharp. This might not always be possible. Extension methods Extension methods should always be in a Extensions folder. They should be in a class that has the name '{ClassItExtends}Extensions'. It should be in a namespace that follows the folder name (so not in the namespace of the class it extends). Extensions of a collection (IEnumerable, List, Array etc) of a type should also be in the class that extends the individual type. Ordering of lon lat In our code we prefor a lon, lat order consistent with the x, y order of most cartographic projections. Some background: The order of lon and lat always causes a lot of confusion. The official notation is lat, lon, but in map projections the lat corresponds to the y-axis and the lon to the x-axis. This is confusing because in math the ordering is the other way around: x, y. In our code we need to translate the lat/lon to an X/Y coordinate to draw it on the map. In the constructor of such a point the x (lon) will be the first parameter. There is no way that this problem can be fundamentally solved, there will always be some confusion. To mitigate it we choose one way of ordering which is lon, lat (consistent with x, y). Also there are many ways in which we can avoid ordering altogher. For instance if we work with Longitude and Latitude properties. In the case of SphericalMercator.FromLonLat we use lon/lat in the method name to avoid confusion. No rendering in the draw/paint loop Mapsui strives for optiomal performance, so in the rendering loop the objects should be ready to be painted to canvas directly without any need for preparation. This is currently (4.0.0-beta.1) not the case. For instance in the case of tiles they are rendered on the first iteration, after that the cached version is used. This needs to be improved. About the terminology Rendering : Create a platform specific resource. SKPath path = ToSKPath(feature, style); Drawing or Painting : Draw the platform specific resource to the canvas. canvas.DrawPath(path, paint); Formatting We use .editorconfig and we should follow these settings. To apply it in Visual Studio you can select your file and run:: sln explorer menu | Analyze and Code Cleanup | Run Code Cleanup (Profile 1 of 2). You can configure which rules to apply in your profile. For xml (not supported by .editorconfig) two spaces indentation is used."
  },
  "documentation/custom-style-renders.html": {
    "href": "documentation/custom-style-renders.html",
    "title": "Custom Style Renderers",
    "keywords": "Custom Style Renderers Summary Mapsui 2.0 supports custom style renderers . This means a user can create a custom style and associate this with a custom style renderer to allow full freedom in rendering a feature the way the user would like. How it works Create a custom style by deriving a class from IStyle. Assign that style to an ILayer.Style or IFeature.Styles. Create a custom renderer by deriving a class from ISkiaStyleRenderer and implement the Draw method. Register the association of the custom style to the custom style renderer as in the line below. The consequence will be that if the Mapsui renderer detects this style it will call the Draw method on the style renderer. This is how you register the association of a custom style to a custom style renderer mapControl.Renderer.StyleRenderers.Add(typeof(CustomStyle), new SkiaCustomStyleRenderer()); This is the ISkiaStyleRenderer interface that you need to implement: public interface ISkiaStyleRenderer : IStyleRenderer { bool Draw(SKCanvas canvas, IReadOnlyViewport viewport, ILayer layer, IFeature feature, IStyle style, ISymbolCache symbolCache); } The IFeature has a Geometry field. The renderer is responsible to cast the IFeature.Geometry to the type it intends to render. The IStyle is the custom style the user defined. It could contain extra style information not present in the default style classes. The user will need to cast that IStyle to the custom style to use this extra information. Code sample Look in the Mapsui source code for CustomStyleSample.cs. This is the most relevant code. In this sample the custom style contains no extra information, it is just an indication to use the associated custom renderer. It would be possible to add extra field like EarColor and NoseSize to the custom style which could be used in the renderer. Remarks Note, that the renderer depends on the technology we use for the rendering implementation, in this case SkiaSharp. Currently we still support XAML as renderer but this may be removed in the future. We expect to support SkiaSharp for a long time but it may be replaced at some point. There are no such plans just yet."
  },
  "documentation/development-constraints.html": {
    "href": "documentation/development-constraints.html",
    "title": "Development constraints",
    "keywords": "Development constraints When developing for Mapsui we take into account the following constraints. Not limited to certain coordinate system Mapsui's Map can be in any coordinate system. If you do not specify a coordinate system in the Map and Layers it assumes they are in the same coordinate system (whatever they are). In this case it only transforms these unspecified 'world-coordinates' to 'screen-coordinates' and nothing more. It is also possible to setup a coordinate transformation system using Map.CRS, DataSource.CRS and Map.Transformation. See projections . Full implementation of the feature matrix These are some of the feature dimensions: Renderers: WPF and Skia Geometries: Point, LineString, Polygon etc. Operations on Geometries: Distance, Contains. Coordinate projection support Style: fill color, line color, line cap, symbol opacity, symbol scale If we choose to support a feature each 'cell' of the multi dimensional matrix should be supported. No surprises for the user. Currently there are holes in the matrix on some point (like differences between WPF and Skia). The current focus is to fill these holes. If this support does not seem attainable (is that proper English?) but does seem very useful we should look for ways to make Mapsui extendable Write clear, simple and little code Maintenance is enemy that can bring a project like this to a halt. We should look for ways to implement the functionality with the simplest possible code."
  },
  "documentation/device-independent-units.html": {
    "href": "documentation/device-independent-units.html",
    "title": "Device Independent Units",
    "keywords": "Device Independent Units Modern devices have a very high resolution. If something is drawn onto the canvas using raw pixels as coordinates the fonts would become tiny and unreadable and lines would become very thin. To correct for this a scale factor is used. Those scaled-up coordinates are called device independent units. Most of the time users deal with the device independent units. In some context they are also called device independent pixels, or dip, or dp. Device Independent Units in SkiaSharp The scale in skia has caused some confusion in the past and bugs as a consequence. So here some extra information on this topic. This is mainly targetted at contributors, users of the Mapsui nugets do not need to know about this. Most (all?) views in SkiaSharp use pixels as coordinates by default but for our purposes we need to use device independent units, so we need to correct for this. We do this by setting the scale of skia's SKCanvas. This needs to be done in the render loop because it is the only place where we have access to the SKCanvas. Also the size of the map needs to be adjusted at that point, otherwise we would draw outsize the screen."
  },
  "documentation/documentation.html": {
    "href": "documentation/documentation.html",
    "title": "Documentation",
    "keywords": "Documentation Documentation setup We use docfx to generate the documentation. There is a /docfx folder with a docfx project called Mapsui. This projects documenation folder contains all the md files used to generate the 'documentation' tab in the site. This is the source of those files, they should be edited there. In the docfx folder there is a script (build-site.cmd) that generates the documentation site (in /docfx/mapsui/_site) and copies it to the /docs folder. The Mapsui project on github is configured to automatically publish this docs folder to https://mapsui.github.io/mapsui A commit of an md file should trigger the build server. This should run the build-site.cmd. This should commit the generated site to the repo. It will when then show up on the website. We should have two separate build configurations one for the docs which ignores the project and one for the project which ignores the docs. Documentation guidelines All md files should be in lower case. All md files should be directly in the root of /docfx. Hierachy is created by indenting page references in the toc.md in the documenation folder. By keeping the files itself in the root it is easier to change the hierarchy later one - you do not need to move the files as well - and easier to get contributers to follow the guidelines. All md files should start with a header one (#) and should have no other header one in that file. All the headers in the toc should be equal to the header one in the file it points to. Mapsui is cased as Mapsui not MapsUI. We should iteratively improve the documentation. If questions are asked in the issues we should search for the answer in the documentation. Update the documentation when it is missing and answer the issue with a url to the documentation. Writing documentation is not only useful to inform the user but also as a sanity check for the developer. If what you have to tell becomes complicated and hard to grasp this could mean the software is not well designed. Writing documentation early should be used as a part of the software development process."
  },
  "documentation/faq.html": {
    "href": "documentation/faq.html",
    "title": "Frequently Asked Questions",
    "keywords": "Frequently Asked Questions The openstreetmap layer does not show The most common reason is that the default user-agent used by the osm layer is blocked. The default user-agent gets blocked by osm at some point because there is always someone somewhere abusing the api. Within your app you need to use a user-agent that is specific to your app. We change the user agent from time to time so that the samples work but it will probably get blocked again at some point. Better not to wait until that happens and create you own user-agent right away. MapControl.Map.Layers.Add(OpenStreetMap.CreateTileLayer(\"your-user-agent\")); Why is all my data in a small area near the west coast of Africa? This is because the background data is in SphericalMercator (it is in the SphericalMercator coordinate system) and the foreground data is in WGS84 (latlon). Use SphericalMercator.FromLonLat to transform it. Note: There can be many other forms of mixing up coordinate systems, but this is the most common. Why does NavigateTo zoom into an area near the west coast of Africa? This is because the coordinates you pass to NavigateTo are in WGS84 whereas the background data is in SphericalMercator. Use SphericalMercator.FromLonLat to transform the NavigateTo arguments to SphericalMercator. Note: There can be many other forms of mixing up coordinate systems, but this is the most common. How can I get rid of the white dots or black lines? In Mapsui v1 and v2 a layer is created with a default style ( Layer.Style ). This style applies to all features in the layer. You need to set the Style field to null if you do not want to use it ( Layer.Style = null ). The default style shows as a white dot on Point geometries and a black line on LineStrings and Polygons. Since most users work with styles on the feature they are not aware of the style on the layer , this make the default style confusing and it should be removed in v3."
  },
  "documentation/getting-started-android.html": {
    "href": "documentation/getting-started-android.html",
    "title": "Mapsui Android getting started",
    "keywords": "Mapsui Android getting started Step 1 Create 'Blank App (Android)' in Visual Studio Step 2 In the package manager console type: PM> Install-Package Mapsui.Android -pre Step 3 In Resources/layout/Main.axml add Mapsui.UI.Android.MapControl: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"> <Mapsui.UI.Android.MapControl android:id=\"@+id/mapcontrol\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /> </LinearLayout> Step 4 In MainActivity.cs add MapControl after SetContentView(Resource.Layout.Main): protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); // Set our view from the \"main\" layout resource SetContentView(Resource.Layout.Main); var mapControl = FindViewById<MapControl>(Resource.Id.mapcontrol); var map = new Map(); map.Layers.Add(OpenStreetMap.CreateTileLayer()); mapControl.Map = map; } Add the following using statements: using Mapsui; using Mapsui.Utilities; using Mapsui.UI.Android; Step 5: Run it and you should see a map of the world."
  },
  "documentation/getting-started-avalonia.html": {
    "href": "documentation/getting-started-avalonia.html",
    "title": "Mapsui Avalonia getting started",
    "keywords": "Mapsui Avalonia getting started Step 1 Create a new Avalonia application in your IDE. You may need to install Avalonia IDE support . Step 2 In the package manager console type: PM> Install-Package Mapsui.Avalonia -pre Step 3 In MainWindow.axaml.cs add this to the constructor after InitializeComponent():: var mapControl = new Mapsui.UI.Avalonia.MapControl(); mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer()); Content = mapControl; Step 4 Run it and you should see a map of the world."
  },
  "documentation/getting-started-eto.html": {
    "href": "documentation/getting-started-eto.html",
    "title": "Mapsui Eto getting started",
    "keywords": "Mapsui Eto getting started Step 1 Start a new Eto.Forms application in Visual Studio. Step 2 In the package manager console type: PM> Install-Package Mapsui.Eto -pre Step 3 In MainForm.cs add this to the class constructor: var mapControl = new Mapsui.UI.Eto.MapControl(); mapControl.Map.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer()); Content = mapControl; Step 4 Run it and you should see a map of the world."
  },
  "documentation/getting-started-ios.html": {
    "href": "documentation/getting-started-ios.html",
    "title": "Mapsui iOS Getting Started",
    "keywords": "Mapsui iOS Getting Started Step 1 Create new 'Single View App' in Visual Studio Step 2 In the package manager console type: PM> Install-Package Mapsui.iOS -pre Step 3 Open ViewController.cs add namespaces: using Mapsui; using Mapsui.UI.iOS; using Mapsui.Utilities; add code to ViewDidLoad() method: public override void ViewDidLoad() { base.ViewDidLoad(); var mapControl = new MapControl(View.Bounds); var map = new Map(); map.Layers.Add(OpenStreetMap.CreateTileLayer()); mapControl.Map = map; View = mapControl; } Step 4 Run it and you should see a map of the world."
  },
  "documentation/getting-started-maui.html": {
    "href": "documentation/getting-started-maui.html",
    "title": "Mapsui MAUI getting started",
    "keywords": "Mapsui MAUI getting started Step 1 Start a new MAUI application in Visual Studio. Step 2 In the package manager console type: PM> Install-Package Mapsui.Maui -pre Step 3 In MauiProgram.cs add .UseSkiaSharp() to the builder like this: builder .UseMauiApp<App>() .UseSkiaSharp() .ConfigureFonts(fonts => and add namespace 'SkiaSharp.Views.Maui.Controls.Hosting': using SkiaSharp.Views.Maui.Controls.Hosting; This is because Mapsui depends on SkiaSharp which needs this call. We hope that this will not be necessary in a future version of Mapsui.Maui. Without this line the app will crash with this exception: \"Catastrophic failure (0x8000FFFF (E_UNEXPECTED))\". Step 4 In MainPage.xaml.cs replace the constuctor with this code: public MainPage() { InitializeComponent(); var mapControl = new Mapsui.UI.Maui.MapControl(); mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer()); Content = mapControl; } Step 5 Run it and you should see a map of the world."
  },
  "documentation/getting-started-uno.html": {
    "href": "documentation/getting-started-uno.html",
    "title": "Mapsui Uno Getting Started",
    "keywords": "Mapsui Uno Getting Started Uno Preparation https://platform.uno/docs/articles/get-started-vs.html Step 1 Create new 'Uno App (Xamarin,UWP)' in Visual Studio Step 2 In the package manager console type: PM> Install-Package Mapsui.Uno -pre repeat this for all the targets you are using (Change the default Project in the Package Manager Console) Step 3 Open MainPage.xaml and add namespace: xmlns:mapsui=\"clr-namespace:Mapsui.UI.Uwp;assembly=Mapsui.UI.Uno\" Add MapControl to the Grid: <Grid> <mapsui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /> </Grid> In MainPage.xaml.cs, add namespace: using Mapsui.Utilities; Add code to the constructor: public MainPage() { this.InitializeComponent(); MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer()); } Step 4 Run it and you should see a map of the world. Troubleshooting Unable to resolve the .NET SDK version as specified in the global.json. global.json (change the version to \"6.0.400\" or what is installed on the Computer) Duplicate Attribute errors: Add following line to the ...Wpf.csproj. <!-- Work around https://github.com/dotnet/wpf/issues/6792 --> <ItemGroup> <FilteredAnalyzer Include=\"@(Analyzer->Distinct())\" /> <Analyzer Remove=\"@(Analyzer)\" /> <Analyzer Include=\"@(FilteredAnalyzer)\" /> </ItemGroup> </Target> System.MissingMethodException: Method not found: See for solution here https://github.com/unoplatform/uno/issues/9297 Upgrading to the latest Uno.UI Dev Version should help too."
  },
  "documentation/getting-started-uno-winui.html": {
    "href": "documentation/getting-started-uno-winui.html",
    "title": "Mapsui Uno Getting Started",
    "keywords": "Mapsui Uno Getting Started Uno Preparation https://platform.uno/docs/articles/get-started-vs.html Step 1 Create new 'Uno Platform App' in Visual Studio Step 2 In the package manager console type: PM> Install-Package Mapsui.Uno.WinUI -pre repeat this for all the targets you are using (Change the default Project in the Package Manager Console) Step 3 Open MainPage.xaml and add namespace: xmlns:mapsui=\"clr-namespace:Mapsui.UI.WinUI;assembly=Mapsui.UI.Uno.WinUI\" Add MapControl to the Grid: <Grid> <mapsui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /> </Grid> In MainPage.xaml.cs, add namespace: using Mapsui.Utilities; Add code to the constructor: public MainPage() { this.InitializeComponent(); MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer()); } Step 4 Run it and you should see a map of the world. Troubleshooting Unable to resolve the .NET SDK version as specified in the global.json. global.json (change the version to \"6.0.400\" or what is installed on the Computer) Duplicate Attribute errors: Add following line to the ...Wpf.csproj. <!-- Work around https://github.com/dotnet/wpf/issues/6792 --> <ItemGroup> <FilteredAnalyzer Include=\"@(Analyzer->Distinct())\" /> <Analyzer Remove=\"@(Analyzer)\" /> <Analyzer Include=\"@(FilteredAnalyzer)\" /> </ItemGroup> </Target> System.MissingMethodException: Method not found: See for solution here https://github.com/unoplatform/uno/issues/9297 Upgrading to the latest Uno.UI Dev Version should help too."
  },
  "documentation/getting-started-winui.html": {
    "href": "documentation/getting-started-winui.html",
    "title": "Mapsui WinUI Getting Started",
    "keywords": "Mapsui WinUI Getting Started Step 1 Create new 'Blank App. Packaged (WinUI 3 in Desktop)' in Visual Studio Step 2 In the package manager console type: PM> Install-Package Mapsui.WinUI -pre Step 3 Open MainPage.xaml and add namespace: xmlns:winui=\"using:Mapsui.UI.WinUI\" Add MapControl to the Grid: <Grid> <winui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /> </Grid> In MainPage.xaml.cs, add namespace: using Mapsui.Utilities; Add code to the constructor: public MainPage() { this.InitializeComponent(); MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer()); } Step 4 Run it and you should see a map of the world."
  },
  "documentation/getting-started-wpf.html": {
    "href": "documentation/getting-started-wpf.html",
    "title": "Mapsui WPF getting started",
    "keywords": "Mapsui WPF getting started Step 1 Start a new WPF application in Visual Studio. Step 2 In the package manager console type: PM> Install-Package Mapsui.Wpf -pre Step 4 In MainWindow.xaml.cs add in the constructor after InitializeComponent(): var mapControl = new Mapsui.UI.Wpf.MapControl(); mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer()); Content = mapControl; Step 4 Run it and you should see a map of the world."
  },
  "documentation/getting-started-xamarin-forms.html": {
    "href": "documentation/getting-started-xamarin-forms.html",
    "title": "Mapsui for Xamarin.Forms getting started",
    "keywords": "Mapsui for Xamarin.Forms getting started Step 1 Create a normal Xamarin.Forms project Step 2 In the package manager console type: PM> Install-Package Mapsui.Forms -pre Step 3 Add the line xmlns:mapsui=\"clr-namespace:Mapsui.UI.Forms;assembly=Mapsui.UI.Forms\" to the Xaml file Step 4 Add the Mapsui.Forms view with <mapsui:MapView x:Name=\"mapView\" VerticalOptions=\"FillAndExpand\" HorizontalOptions=\"Fill\" BackgroundColor=\"Gray\" /> to the Xaml part file. Nest the MapView element inside a container, this child element needs to be placed inside a parent Layout for the view to be correctly setup and attached to the code behind, for instance, <?xml version=\"1.0\" encoding=\"utf-8\" ?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:d=\"http://xamarin.com/schemas/2014/forms/design\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:mapsui=\"clr-namespace:Mapsui.UI.Forms;assembly=Mapsui.UI.Forms\" mc:Ignorable=\"d\"> <StackLayout> <mapsui:MapView x:Name=\"mapView\" VerticalOptions=\"FillAndExpand\" HorizontalOptions=\"Fill\" BackgroundColor=\"Gray\" /> </StackLayout> </ContentPage> the Xaml file should look similar to this after this step. Step 5 Add in the code behind the following var map = new Map { CRS = \"EPSG:3857\", Transformation = new MinimalTransformation() }; var tileLayer = OpenStreetMap.CreateTileLayer(); map.Layers.Add(tileLayer); map.Widgets.Add(new Widgets.ScaleBar.ScaleBarWidget(map) { TextAlignment = Widgets.Alignment.Center, HorizontalAlignment = Widgets.HorizontalAlignment.Left, VerticalAlignment = Widgets.VerticalAlignment.Bottom }); mapView.Map = map; Step 6 Run it and you should see a map of the world."
  },
  "documentation/home.html": {
    "href": "documentation/home.html",
    "title": "Introduction",
    "keywords": "Introduction Mapsui is a .NET component to show a map in your app. Supported platforms in v3 Xamarin.Forms WPF UWP Xamarin.Android Xamarin.iOS Upcoming in v4 Avalonia Eto.Forms MAUI Uno platform Win UI Supported data Points, Lines and Polygons. Mapsui uses the BruTile library to display tile layers such as: OpenStreetMap tiles WMTS TMS WMS MBTiles. An offline format to store tile data in sqlite file."
  },
  "documentation/how-to-work-with-mapsui.html": {
    "href": "documentation/how-to-work-with-mapsui.html",
    "title": "How to Work with Mapsui",
    "keywords": "How to Work with Mapsui Logging Sooner or later there comes a time where you are struggling with a bug. You can save yourself some time by writing the Mapsui log events to your own log from the start of your project. In Mapsui errors and warnings are logged to a static class which has an event handler you can listen to. Mapsui.Logging.Logger.LogDelegate += (level, message, ex) => // todo: Write to your own logger; Extension of Mapsui If you need more functionality from the MapControl you could create your own version of the MapControl by making a copy. You can customize these for your own needs. While it is also possible to extend functionality by adding your own ILayer or IProvider implementation. If you encounter breaking changes please take a look at the release notes . You can check the related commits by clicking the 'x commits to masters since this release' of the previous release (a bit odd but that is how github works)."
  },
  "documentation/logging.html": {
    "href": "documentation/logging.html",
    "title": "Logging",
    "keywords": "Logging Sooner or later there comes a time where you are struggling with a bug. You can save yourself some time by writing the Mapsui log events to your own log from the start of your project. In Mapsui errors and warnings are logged to a static class which has an event handler you can listen to. Mapsui.Logging.Logger.LogDelegate += (level, message, ex) => // todo: Write to your own logger; This is an example of how to forward it to Microsoft.Extensions.Logging.ILogger public static void AttachMapsuiLogging(this IServiceProvider serviceProvider) { var logger = serviceProvider.GetRequiredService<ILogger<MyLoggerCategory>>(); var mapsuiPrefix = \"[Mapsui]\"; Mapsui.Logging.Logger.LogDelegate += (level, message, ex) => { if (level == Mapsui.Logging.LogLevel.Error) logger.LogError(ex, $\"{mapsuiPrefix} {message}\"); else if (level == Mapsui.Logging.LogLevel.Warning) logger.LogWarning(ex, $\"{mapsuiPrefix} {message}\"); else if (level == Mapsui.Logging.LogLevel.Information) logger.LogInformation(ex, $\"{mapsuiPrefix} {message}\"); else if (level == Mapsui.Logging.LogLevel.Debug) logger.LogDebug(ex, $\"{mapsuiPrefix} {message}\"); else if (level == Mapsui.Logging.LogLevel.Trace) logger.LogTrace(ex, $\"{mapsuiPrefix} {message}\"); }; }"
  },
  "documentation/mapsui-components.html": {
    "href": "documentation/mapsui-components.html",
    "title": "Mapsui Components",
    "keywords": "Mapsui Components If you install the NuGet package into your app these assemblies are added: Mapsui.UI.{platform} - Platform specific UI. Contains the MapControl Mapsui.Rendering.Skia Mapsui Mapsui.Geometries On Windows desktop Mapsui.Rendering.Xaml is added. A number of nuget dependencies Mapsui Parts There are three important classes that you will deal with MapControl This is the UI component that you add to you project. Map Holds all information about the map like layers and widgets. Viewport Holds all information about the part of the map that is visible on the screen like center, extent, rotation, resolution and so on. It is created automatically when Map is created. You can access it with MapControl.Map.Viewport."
  },
  "documentation/mapsui-forms.html": {
    "href": "documentation/mapsui-forms.html",
    "title": "Mapsui.Forms",
    "keywords": "Mapsui.Forms Mapsui can be used on Xamarin.Forms with the Mapsui.Forms nuget package. Mapsui.Forms is a 'native' Xamarin.Forms implementation, meaning it does not use Xamarin.Forms Renderers around platform specific components but implements a Xamarin.Forms implementation instead. Mapsui.Forms uses SkiaSharp.Views.Forms to display the map on the device. This works for iOS, Android, UWP and Mac OS. On WPF there still is an issue with placing controls over the Map. To get started see getting started with Xamarin.Forms ."
  },
  "documentation/nuget-of-latest-build.html": {
    "href": "documentation/nuget-of-latest-build.html",
    "title": "NuGet of Latest Build",
    "keywords": "NuGet of Latest Build On every commit the build server is triggered which publishes a NuGet package of that build. It's version number is the current version of the master branch followed by a dot and the build number. The package is not published to nuget.org but to a AppVeyor feed. You can see the latest packages here . You need to add this feed to be able to install the package to your project. Add the feed in Visual Studio Add the feed in tools | options | nuget | package sources https://ci.appveyor.com/nuget/mapsui Install the package PM> nuget install-package mapsui -source https://ci.appveyor.com/nuget/mapsui -pre This installs only the mapsui core package but you could install any other package this way. Build your own nuget package It is also possible to build you own nuget package locally by running scripts\\buildpack.bat 3.0.0-custom.1 from the sln folder. You can set the file location as a Package Source in visual studio."
  },
  "documentation/performance-widget.html": {
    "href": "documentation/performance-widget.html",
    "title": "PerformanceWidget",
    "keywords": "PerformanceWidget Summary Mapsui 3.0 supports a widget, that could show the main performance values for drawing the map. How it works 1) Create a new Performance object for the MapControl, where the values could be stored if (mapControl.Performance == null) mapControl.Performance = new Utilities.Performance(10); 2) Create the PerformanceWidget. As parameter you have to provide the Performance object, that the widget should be use var widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance); 3) If you want to clear all values of the Performance object, then add the following event handler for the touch event of the widget widget.WidgetTouched += (sender, args) => { mapControl?.Performance.Clear(); mapControl?.RefreshGraphics(); args.Handled = true; }; 4) Add the widget to the list of known widgets mapControl.Map.Widgets.Add(widget); 5) To draw the widget on the screen, we need a widget renderer. To use the default widget renderer, use the following lines mapControl.Renderer.WidgetRenders[typeof(Widgets.Performance.PerformanceWidget)] = new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White); The first two parameters are the X and Y coordiantes for the widget. Third parameter is the text size. Fourth is the text color and fifth is the background color. Code copy if (mapControl.Performance == null) mapControl. Performance = new Utilities.Performance(); var widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance); widget.WidgetTouched += (sender, args) => { mapControl?.Performance.Clear(); mapControl?.RefreshGraphics(); args.Handled = true; }; mapControl.Map.Widgets.Add(widget); mapControl.Renderer.WidgetRenders[typeof(Widgets.Performance.PerformanceWidget)] = new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White); Values Last Time for drawing of the last screen. Be careful: because the widget is drawn together with the screen, this time is the time for the screen drawn before the screen you see. Mean The mean value is the mean of the last x draws. x is the number, you provide when creating the Performance object. Frames per second This is the number of frames that could be drawn with the actual mean drawing time. Minimum Fastest draw of the screen. Maximum Slowest draw of the screen. Count How often the screen is drawn. Dropped How often the screen isn't invalidated, because a drawing is still in progress. Remarks The Performance object contains the times between start and end of a drawing process. This must not be the real drawing time. It could be, that other tasks running in between the drawing process."
  },
  "documentation/projections.html": {
    "href": "documentation/projections.html",
    "title": "Projections",
    "keywords": "Projections A geospatial projection is the transformation of coordinates in one coordinate system to another coordinate system. If all your data is in one coordinate system there is no need for projection. With a geospectial projection we do not mean transforming spatial coordinates to pixel positions on screen. To distinguish it from that kind of transformation we use the term projection instead of transformation for geospatial projections in Mapsui, although these words mean rougly the same. Some background on projections The topic of geospatial projections is complicated. Users of Mapsui have a wide variety of backgrounds. Some are experienced GIS users that just need to know how this specific map component works. Many others are app developers that just happen to need a map for their current app. This makes it hard to explain things clear for everyone. Below are some basic concepts. I like this video introduction to map projections. Spatial Reference System (CRS) In geospatial there is a standard way to refer to a coordinate systems, the CRS (coordinate reference system). We will use the term CRS to refer to a specific coordinate system. In Mapsui the Map and the IProvider have a CRS field to indicate their coordinate systems. Supported coordinate systems (CRSes) Out of the box Mapsui only supports the projection between two coordinate systems. EPSG:4326 or lat/lon, or WGS84. GPS coordinates are in lat/lon EPSG:3857 or SphericalMercator, or WebMercator, PseudoMercator. This is the coordinate system used in the maps of google and openstreetmap. It is however possible to create your own projection. You need to implement the IProjection interface. Within this implementation you need to use some other projection library. A recommended one is ProjNet4GeoAPI . Parts of Mapsui involved in projections Map : There is one Map. It is inevitably in some kind of coordinate system. Layers : There are several layers that provider data. The layers always need to return data in the coordinate system that the map is using. If not, different projections will be drawn on top of each other and things go wrong. Providers : Some Layers have a DataSource (Provider). This DataSource could contain data in another coordinate system. This data can be converted to the map coordinate system using the ProjectingProvider. The most common scenario If you use OpenStreetMap the map is in SphericalMercator. Often you have geodata in lat/lon, say a GPS track. The Map.CRS has to be set. If you use SphericalMercator set it to \"EPSG:3857\". The Provider.CRS has to be set. If the data is in lat/lon set it to \"EPSG:4326\". Wrap the Provider om the ProjectingProvider. Search the code samples for ProjectingProvider. With this setup the ProjectingProvider will do the projection for you. Another option is to do the projection yourself. You can use Mapsui's SphericalMerator.FromLonLat/ToLonLat to project the data before you add them to a Memorylayer and no CRSes need to be set. Remarks Mapsui is not capable of projecting images. So no projection of tiles as rasters. No attempt will be made to project and the CRS fields will be ignored. Sample <!-- Tag name projectionsample is not found --> using Mapsui.Extensions; using Mapsui.Layers; using Mapsui.Providers; using Mapsui.Samples.Common.Desktop.GeoData; using Mapsui.Styles; using Mapsui.Tiling; using Mapsui.UI; using System.Threading.Tasks; namespace Mapsui.Samples.Common.Maps.Projection { public class PointProjectionSample : ISample { public string Name => \"Point projection\"; public string Category => \"Projection\"; public Task<Map> CreateMapAsync() { // For Projections to work three things need to be set: // 1) The CRS on the Map to know what to project to. // 2) The CRS on the DataSource to know what to project from. // 3) The projection to project from the DataSource CRS to // the Map CRS. var geometryLayer = CreateWorldCitiesLayer(); var extent = geometryLayer.Extent!.Grow(10000); var map = new Map { CRS = \"EPSG:3857\", // The Map CRS needs to be set BackColor = Color.Gray }; map.Layers.Add(OpenStreetMap.CreateTileLayer()); map.Layers.Add(geometryLayer); map.Home = n => n.NavigateTo(extent); return Task.FromResult(map); } public static Layer CreateWorldCitiesLayer() { var features = WorldCities.GenerateTop100(); var memoryProvider = new MemoryProvider(features) { CRS = \"EPSG:4326\" // The DataSource CRS needs to be set }; var dataSource = new ProjectingProvider(memoryProvider) { CRS = \"EPSG:3857\" }; return new Layer { DataSource = dataSource, Name = \"Cities\", Style = CreateCityStyle(), IsMapInfoLayer = true }; } private static SymbolStyle CreateCityStyle() { var location = typeof(GeodanOfficesSample).LoadBitmapId(\"Images.location.png\"); return new SymbolStyle { BitmapId = location, SymbolOffset = new Offset { Y = 64 }, SymbolScale = 0.25, Opacity = 0.5f }; } } }"
  },
  "documentation/renderers.html": {
    "href": "documentation/renderers.html",
    "title": "Renderers",
    "keywords": "Renderers As of v4 Mapsui has only one renderer, Skia. We still use a renderer interface but there are no plans to add another renderer atm. Why use an IRenderer interface? If you know there is only one renderer why work with an interface. Some things can be simplified if you directly work with the implementation. Since it looks more and more like skiasharp will be the only renderer for as far as we can see we could just add that dependency to all our code and work directly with SkiaSharp classes, that may simplify some things. However, in the past we had to switch many times to different renderers, so I am not so sure if this won't happen again. So let's not settle for one renderer just yet. For context, these are the renderers Mapsui had in the past: System.Drawing System.Drawing for PocketPC Silverlight XAML WPF XAML UWP XAML (could later be merged with WPF XAML) iOS native rendering Android native rendering (this is actually internally using skia) OpenTK (this was not mature enough at that point) SkiaSharp"
  },
  "documentation/rendering-tests.html": {
    "href": "documentation/rendering-tests.html",
    "title": "Rendering Tests",
    "keywords": "Rendering Tests Mapsui has a way of testing rendering where a Map state is rendered to a bitmap. This bitmap is then compared to the original images which are stored as resource in the repository. This is thus a kind of regresssion test (1). If there are differences between these images the test will fail. If this is the case the developer needs to visually inspect the generated images (2). If the generated image is as expected and the original is not then the original needs to be overwritten. Regression tests Visual inspection. The regression tests are useful during refactoring when you expect no changes. When you are working on changes in the rendered output the regression tests will fail but the visual inspection of the output is still useful to check if this is as intended. 1. Regression tests The generated images are written to: {test project folder}\\bin\\Debug\\net6.0\\Resources\\Images\\Generated Those will be compared to the original images that were deployed in the build located here: {test project folder}\\bin\\Debug\\net6.0\\Resources\\Images\\Original\\ If after code changes there are expected changes in the generated files they should be committed to git so they need to be copied to: {test project folder}\\Resources\\Images\\Original\\ This can be done with a script: scripts\\test-image-copier.cmd . 2. Visual inspection There tests can be inspected in two ways. In the WPF sample there is a 'Tests' category, that shows an interactive version of the test sample. In the output folder (see above) the generated images can be viewed. Currently this folder looks like this:"
  },
  "documentation/resolution.html": {
    "href": "documentation/resolution.html",
    "title": "Resolution",
    "keywords": "Resolution In Mapsui the resolution is a value that indicates to what degree the map is zoomed in or zoomed out. A large value means you are zoomed out (see the whole world), a small value means you are zoomed in (looking at the details). The resolution of a viewport is its size in map coordinates (of the coordinate system used) devided by its size in pixels. If you use the openstreetmap background layer (or another layer in that coordinates system) the resolution is meters / pixel at the equator. The resolution of the Mapsui viewport The Viewport is an important class in Mapsui. It has a Resolution field. Its value can be directly derived from the coordinate extent and the size in pixels. So Viewport.Resolution will always be equal to Viewport.Extent.Width / Viewport.Width. The Viewport.Extent is in the units of the coordinate system (different apps can use different coordinate systems) and the Viewport.Width/Height is in pixels. The resolution in openstreetmap Mapsui's resolution concept is derived from the value for zoom levels used in openstreetmap tile schema . Openstreetmap uses the EPSG:3857 coordinate system (called SphericMercator within Mapsui). The full width of that coordinate system is 40075017 units. The top level tile in openstreetmap is 256x256 pixels. So the top level tile has a resolution of 40075017 / 256 = 156543 if is shown unscaled. Scale in meters / pixel in openstreetmap The coordinates of EPSG:3857 happen to be based on the circumference of the earth in meters at the equator which is 40075017 meters . This means that near the equator the units of EPSG:3875 are equal to meters. It starts to deviate when moving away from the equator. Also note that other coordinate systems can have completely different unit sizes. So the relation between the coordinate system used and meters is complicated. I am just interested in meters / pixel and don't care about the coordinate system That makes sense but at the moment there is no good solution for that in Mapsui. What makes this complicated: The meters / pixel can be different in the x and y direction because of distortion of the map projection. The meters / pixel can be different for different locations within a single map view. To implement this for a coordinate system we need projection support for that coordinate system, which we may not have. What is a pixel? When we talk about pixels on this page we mean device independent pixels or device independent units"
  },
  "documentation/roadmap.html": {
    "href": "documentation/roadmap.html",
    "title": "Roadmap",
    "keywords": "Roadmap Updated March 2022 v4 Use NTS for geometries License to MIT Improvements around Mapsui: Improve the documentation. Adding 'getting started' tutorials for all platforms. Improve the samples. Add comments, make them smaller (single purpose) and make them look better. Options for v5 Improve performance World wrap Add vector tiles"
  },
  "documentation/samples.html": {
    "href": "documentation/samples.html",
    "title": "Samples",
    "keywords": "Samples The best way to get started with mapsui is to download the source and run a samples app. There are sample apps for each supported platform. On Windows you could run Mapsui.Samples.Wpf . In the dropdown at the top left you can select between different categories. With the option buttons you can select between specific samples. All these samples correspond to a specific sample class that is derived from ISample. Where can I find the code for the samples? The samples can be found in this folder: Samples\\Mapsui\\Mapsui.Samples.Common\\Maps. The most easy way to find them is to search for the name of the sample that is shown after the option button. For instance \"1 Points\" For master look here For 3.0 look here For 2.0 look here For 1.4 look here"
  },
  "documentation/v2.0-upgrade-guide.html": {
    "href": "documentation/v2.0-upgrade-guide.html",
    "title": "v2.0 upgrade guide",
    "keywords": "v2.0 upgrade guide This is the incomplete upgrade guide from v1.4 to v2.0. The most apparent changes will be mentioned here. If you notice important things missing then please post an issue. Moved from PCL to .NET Standard 2.0 Look up compatible frameworks in this table . Viewport moved from Map to MapControl and is readonly Use MapControl.Navigator instead. Moved MapControl.NavigateTo methods to MapControl.Navigator All user map manipulation should go the the Navigator. Introduced Map.Home to initialze the map viewport There is now a Home delegate on the Map object that should be used to set the initial state of the map. MapControl.Map.Home = n => n.NavigateTo(myCenter, myResolution); Reason: This is because in some cases the Navigate methods depend on the envelope and resolutions of the layers and in some cases it takes time for these layers to load their data. Added Map.PanLock, Map.ZoomLock and Map.RotationLock The lock fields can be used on all platforms to lock the user from a certain kind of map manipulation. Added Map.Limiter to limit the extent to which the user can navigate The Limter is an implementation of IViewportLimiter. There are currently three limiters part of Mapsui: ViewportLimiter (default) ViewportLimiterKeepWithin ViewportLimiterWithoutLimits It is also possible to implement your own IViewportLimiter. Added RefreshGraphics, RefreshData and Refresh Use RefreshGraphics if you know the data in the layer has changed and the graphics needs refreshing. Use RefreshData if you know there is new data available in the source. Use Refresh if you need to do both. These methods should only be needed if you manipulate data somehow in your own code. Renamed BoundingBox GetCentroid to Centroid and GetBoundingBox to BoundingBox Turned these methods into proper properties making user code a bit more compact. The Info event was moved from Map to MapControl The MapControl contains most other events as well Removed the InfoLayer list and add an InfoLayer boolean on ILayer To indicate that a layer is a info layer you now need to set it's InfoLayer property. In v1.4 it had to be added to the list of InfoLayers. Removed the HoverLayer method. This is because hover could not be implemented crossplatform and could harm performance. It it is still possible to implement hover yourself using a direct call to MapControl.GetMapInfo. Invert label alignment bottom/top. This was incorrect in v1.4. This will not cause a compile error so don't forget to do a search-replace to fix it. Removed ZoomIn/ZoomOut from WPF MapControl Use the ZoomIn/ZoomOut methode on the navigator. Some other changes Move Info event from Map to MapControl Do not derive ILayer from IAsyncDataFetcher. Remove WPFs MapControl.ErrorMessage Rename PanMode.None and ZoomMode.None. Remove the InfoLayer list and add an InfoLayer boolean on ILayer Remove the HoverLayer method. It is not crossplatform and can affect performance. Wrap Viewport in LimitingViewport which limits it to user settings, or access through Navigator. PanLock and ZoomLock working on all platforms. Rework ViewportLimiter"
  },
  "documentation/v4.0-upgrade-guide.html": {
    "href": "documentation/v4.0-upgrade-guide.html",
    "title": "v4.0 upgrade guide",
    "keywords": "v4.0 upgrade guide namespace changes & renaming v3 v4 Mapsui.Geometries (removed) Mapsui.Geometries.Point Mapsui.MPoint Mapsui.Geometries.BoundingBox Mapsui.MRect Mapsui.Layers.TileLayer Mapsui.Tiling.Layers.TileLayer Mapsui.Projection Mapsui.Projections Mapsui.Rendering.Skia.CalloutType Mapsui.Styles.CalloutType"
  },
  "index.html": {
    "href": "index.html",
    "title": "Mapsui documentation.",
    "keywords": "Mapsui documentation. This is the documentation of the Mapsui open source map component. For general documentation go here . For API documentation go here . For the github repository, which also contains the samples, go here . Projects that use Mapsui Breath Companion Squadra @mapsui-users Please send info on other apps using Mapsui to add them here Support If you are interested in more support for Mapsui please mail pauldendulk@gmail.com ."
  }
}