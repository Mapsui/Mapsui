<!--
***********************************************************************************************
NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************

  This target file contains the NuGet Restore target for walking the project and reference graph
  and restoring dependencies from the graph.

  Ways to use this targets file:
  1. Invoke it directly and provide project file paths using $(RestoreGraphProjectInput).
  2. With a solution this may be used as a target in the metaproj.
  3. Import the targets file from a project.

  Restore flow summary:
  1. Top level projects (entry points) are determined.
  2. Each project and all of its project references are walked recursively.
  3. The project is evaluated for each $(TargetFramework). Items are created
     for project properties and dependencies. Each item is marked
     with the project it came from so that it can be matched up later.
  4. All restore items generated by the walk are grouped together by
     project and convert into a project spec.

  The result file contains:
  1. A list of projects to restore.
  2. The complete closure of all projects referenced (Includes project references that are not being restored directly).
  3. Package and project dependencies for each project.
  4. DotnetCliTool references
  -->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <!-- Mark that this target file has been loaded.  -->
    <IsRestoreTargetsFileLoaded>true</IsRestoreTargetsFileLoaded>
    <!-- Load NuGet.Build.Tasks.dll, this can be overridden to use a different version with $(RestoreTaskAssemblyFile) -->
    <RestoreTaskAssemblyFile Condition=" '$(RestoreTaskAssemblyFile)' == '' ">NuGet.Build.Tasks.dll</RestoreTaskAssemblyFile>
    <!-- Do not hide errors and warnings by default -->
    <HideWarningsAndErrors Condition=" '$(HideWarningsAndErrors)' == '' ">false</HideWarningsAndErrors>
    <!-- Recurse by default -->
    <RestoreRecursive Condition=" '$(RestoreRecursive)' == '' ">true</RestoreRecursive>
    <RestoreUseSkipNonexistentTargets Condition=" '$(RestoreUseSkipNonexistentTargets)' == '' ">true</RestoreUseSkipNonexistentTargets>
    <!-- RuntimeIdentifier compatibility check -->
    <ValidateRuntimeIdentifierCompatibility Condition=" '$(ValidateRuntimeIdentifierCompatibility)' == '' ">false</ValidateRuntimeIdentifierCompatibility>
    <!-- Error handling while walking projects -->
    <RestoreContinueOnError Condition=" '$(RestoreContinueOnError)' == '' ">WarnAndContinue</RestoreContinueOnError>
    <!-- Build in parallel -->
    <RestoreBuildInParallel Condition=" '$(BuildInParallel)' != '' ">$(BuildInParallel)</RestoreBuildInParallel>
    <RestoreBuildInParallel Condition=" '$(RestoreBuildInParallel)' == '' ">true</RestoreBuildInParallel>
    <!-- Check if the restore target was executed on a sln file -->
    <_RestoreSolutionFileUsed Condition=" '$(_RestoreSolutionFileUsed)' == '' AND '$(SolutionDir)' != '' AND $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' ">true</_RestoreSolutionFileUsed>
    <!-- We default to MSBuildInteractive. -->
    <NuGetInteractive Condition=" '$(NuGetInteractive)' == '' ">$(MSBuildInteractive)</NuGetInteractive>
    <!-- Mark that this targets file supports package download. -->
    <PackageDownloadSupported>true</PackageDownloadSupported>
    <!-- Mark that this targets file GetReferenceNearestTargetFrameworkTask task supports the TargetPlatformMoniker -->
    <GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>true</GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>
    <!-- Flag if the Central package file is enabled -->
    <_CentralPackageVersionsEnabled Condition="'$(ManagePackageVersionsCentrally)' == 'true' AND '$(CentralPackageVersionsFileImported)' == 'true'">true</_CentralPackageVersionsEnabled>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Exclude packages from changing restore inputs.  -->
    <_GenerateRestoreGraphProjectEntryInputProperties>ExcludeRestorePackageImports=true</_GenerateRestoreGraphProjectEntryInputProperties>

    <!-- Standalone mode
         This is used by NuGet.exe to inject targets into the project that will be
         walked next. In normal /t:Restore mode this causes a duplicate import
         since NuGet.targets it loaded as part of MSBuild, there is should be
         skipped. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(RestoreUseCustomAfterTargets)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      NuGetRestoreTargets=$(MSBuildThisFileFullPath);
      RestoreUseCustomAfterTargets=$(RestoreUseCustomAfterTargets);
      CustomAfterMicrosoftCommonCrossTargetingTargets=$(MSBuildThisFileFullPath);
      CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
    </_GenerateRestoreGraphProjectEntryInputProperties>

    <!-- Include SolutionDir and SolutionName for solution restores and persist these properties during the walk. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(_RestoreSolutionFileUsed)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      _RestoreSolutionFileUsed=true;
      SolutionDir=$(SolutionDir);
      SolutionName=$(SolutionName);
      SolutionFileName=$(SolutionFileName);
      SolutionPath=$(SolutionPath);
      SolutionExt=$(SolutionExt);
    </_GenerateRestoreGraphProjectEntryInputProperties>
  </PropertyGroup>

  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.RestoreTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WriteRestoreGraphTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectJsonPathTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetCentralPackageVersionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageDownloadsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreFrameworkReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreDotnetCliToolsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSolutionProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSettingsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.WarnForInvalidProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetReferenceNearestTargetFrameworkTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectStyleTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.NuGetMessageTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.CheckForDuplicateNuGetItemsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetGlobalPropertyValueTask" AssemblyFile="$(RestoreTaskAssemblyFile)" />

  <!--
    ============================================================
    Restore
    Main entry point for restoring packages
    ============================================================
  -->
  <Target Name="Restore" DependsOnTargets="_GenerateRestoreGraph">

    <!-- Drop any duplicate items -->
    <RemoveDuplicates
      Inputs="@(_RestoreGraphEntry)">
      <Output
          TaskParameter="Filtered"
          ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>

    <!-- Call restore -->
    <RestoreTask
      RestoreGraphItems="@(_RestoreGraphEntryFiltered)"
      RestoreDisableParallel="$(RestoreDisableParallel)"
      RestoreNoCache="$(RestoreNoCache)"
      RestoreIgnoreFailedSources="$(RestoreIgnoreFailedSources)"
      RestoreRecursive="$(RestoreRecursive)"
      RestoreForce="$(RestoreForce)"
      HideWarningsAndErrors="$(HideWarningsAndErrors)"
      Interactive="$(NuGetInteractive)"
      RestoreForceEvaluate="$(RestoreForceEvaluate)"
      RestorePackagesConfig="$(RestorePackagesConfig)"/>
  </Target>

  <!--
    ============================================================
    GenerateRestoreGraphFile
    Writes the output of _GenerateRestoreGraph to disk
    ============================================================
  -->
  <Target Name="GenerateRestoreGraphFile" DependsOnTargets="_GenerateRestoreGraph">
    <!-- Validate  -->
    <Error Condition="$(RestoreGraphOutputPath) == ''" Text="Missing RestoreGraphOutputPath property!" />

    <!-- Drop any duplicate items -->
    <RemoveDuplicates
        Inputs="@(_RestoreGraphEntry)">
      <Output
          TaskParameter="Filtered"
          ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>

    <!-- Write file -->
    <WriteRestoreGraphTask
      RestoreGraphItems="@(_RestoreGraphEntryFiltered)"
      RestoreGraphOutputPath="$(RestoreGraphOutputPath)"
      RestoreRecursive="$(RestoreRecursive)" />
  </Target>

  <!--
    ============================================================
    CollectPackageReferences
    Gathers all PackageReference items from the project.
    This target may be used as an extension point to modify
    package references before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageReferences" Returns="@(PackageReference)" >
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageReferencesContinueOnError>$(ContinueOnError)</CollectPackageReferencesContinueOnError>
      <CollectPackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageReferencesContinueOnError>
    </PropertyGroup>

    <CheckForDuplicateNuGetItemsTask
      Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' "
      Items="@(PackageReference)"
      ItemName="PackageReference"
      LogCode="NU1504"
      MSBuildProjectFullPath="$(MSBuildProjectFullPath)"
      TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
      WarningsAsErrors="$(WarningsAsErrors)"
      NoWarn="$(NoWarn)"
      ContinueOnError="$(CollectPackageReferencesContinueOnError)"
      >
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageReferences" />
    </CheckForDuplicateNuGetItemsTask>

    <ItemGroup Condition="'@(DeduplicatedPackageReferences)' != ''">
      <PackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(DeduplicatedPackageReferences)" />
    </ItemGroup>

  </Target>

  <!--
    ============================================================
    CollectCentralPackageVersions
    Gathers all PackageVersion items from the central package versions file.
    ============================================================
  -->
  <Target Name="CollectCentralPackageVersions" Returns="@(PackageVersion)">

    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectCentralPackageVersionsContinueOnError>$(ContinueOnError)</CollectCentralPackageVersionsContinueOnError>
      <CollectCentralPackageVersionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectCentralPackageVersionsContinueOnError>
    </PropertyGroup>

    <CheckForDuplicateNuGetItemsTask
      Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' "
      Items="@(PackageVersion)"
      ItemName="PackageVersion"
      LogCode="NU1506"
      MSBuildProjectFullPath="$(MSBuildProjectFullPath)"
      TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
      WarningsAsErrors="$(WarningsAsErrors)"
      NoWarn="$(NoWarn)"
      ContinueOnError="$(CollectCentralPackageVersionsContinueOnError)"
      >
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageVersions" />
    </CheckForDuplicateNuGetItemsTask>

    <ItemGroup Condition="'@(DeduplicatedPackageVersions)' != ''">
      <PackageVersion Remove="@(PackageVersion)" />
      <PackageVersion Include="@(DeduplicatedPackageVersions)" />
    </ItemGroup>

  </Target>

  <!--
    ============================================================
    CollectPackageDownloads
    Gathers all PackageDownload items from the project.
    This target may be used as an extension point to modify
    package downloads before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageDownloads" Returns="@(PackageDownload)">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageDownloadsContinueOnError>$(ContinueOnError)</CollectPackageDownloadsContinueOnError>
      <CollectPackageDownloadsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageDownloadsContinueOnError>
    </PropertyGroup>

    <CheckForDuplicateNuGetItemsTask
      Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' "
      Items="@(PackageDownload)"
      ItemName="PackageDownload"
      LogCode="NU1505"
      MSBuildProjectFullPath="$(MSBuildProjectFullPath)"
      TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
      WarningsAsErrors="$(WarningsAsErrors)"
      NoWarn="$(NoWarn)"
      ContinueOnError="$(CollectPackageDownloadsContinueOnError)"
      >
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageDownloads" />
    </CheckForDuplicateNuGetItemsTask>

    <ItemGroup Condition="'@(DeduplicatedPackageDownloads)' != ''">
      <PackageDownload Remove="@(PackageDownload)" />
      <PackageDownload Include="@(DeduplicatedPackageDownloads)" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    CollectFrameworkReferences
    ============================================================
  -->
  <Target Name="CollectFrameworkReferences" Returns="@(_FrameworkReferenceForRestore)">
    <ItemGroup>
      <_FrameworkReferenceForRestore
        Include="@(FrameworkReference)"
        Condition="'%(FrameworkReference.IsTransitiveFrameworkReference)' != 'true'"/>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _LoadRestoreGraphEntryPoints
    Find project entry points and load them into items.
    ============================================================
  -->
  <Target Name="_LoadRestoreGraphEntryPoints" Returns="@(RestoreGraphProjectInputItems)">

    <!-- Allow overriding items with RestoreGraphProjectInput -->
    <ItemGroup Condition=" @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(RestoreGraphProjectInput)" />
    </ItemGroup>

    <!-- Project case -->
    <ItemGroup Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) != 'true' AND @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>

    <!-- Solution case -->
    <GetRestoreSolutionProjectsTask
      Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' AND @(RestoreGraphProjectInputItems) == '' "
      ProjectReferences="@(ProjectReference)"
      SolutionFilePath="$(MSBuildProjectFullPath)">
      <Output
        TaskParameter="OutputProjectReferences"
        ItemName="RestoreGraphProjectInputItems" />
    </GetRestoreSolutionProjectsTask>
  </Target>

  <!--
    ============================================================
    _FilterRestoreGraphProjectInputItems
    Filter out unsupported project entry points.
    ============================================================
  -->
  <Target Name="_FilterRestoreGraphProjectInputItems" DependsOnTargets="_LoadRestoreGraphEntryPoints"
    Returns="@(FilteredRestoreGraphProjectInputItems)">

    <PropertyGroup>
      <RestoreProjectFilterMode Condition=" '$(RestoreProjectFilterMode)' == '' ">exclusionlist</RestoreProjectFilterMode>
    </PropertyGroup>

    <!-- Filter to a list of known supported types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp
       Include="@(RestoreGraphProjectInputItems)"
       Condition=" '%(RestoreGraphProjectInputItems.Extension)' == '.csproj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.vbproj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.fsproj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.nuproj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.proj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.msbuildproj' Or
                   '%(RestoreGraphProjectInputItems.Extension)' == '.vcxproj' " />
    </ItemGroup>

    <!-- Filter out disallowed types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'exclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp
       Include="@(RestoreGraphProjectInputItems)"
       Condition=" '%(RestoreGraphProjectInputItems.Extension)' != '.metaproj'
                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.shproj'
                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vcxitems'
                   AND '%(RestoreGraphProjectInputItems.Extension)' != '' " />
    </ItemGroup>

    <!-- No filtering -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' != 'exclusionlist' AND '$(RestoreProjectFilterMode)' != 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp
        Include="@(RestoreGraphProjectInputItems)" />
    </ItemGroup>

    <!-- Remove duplicates -->
    <RemoveDuplicates
      Inputs="@(_FilteredRestoreGraphProjectInputItemsTmp)">
      <Output
          TaskParameter="Filtered"
          ItemName="FilteredRestoreGraphProjectInputItemsWithoutDuplicates" />
    </RemoveDuplicates>

    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' "
        BuildInParallel="$(RestoreBuildInParallel)"
        Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)"
        Targets="_IsProjectRestoreSupported"
        SkipNonexistentTargets="true"
        Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>

    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' "
      Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)"
      Targets="_IsProjectRestoreSupported"
      ContinueOnError="$(RestoreContinueOnError)"
      Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>

    <!-- Warn for projects that do not support restore. -->
    <WarnForInvalidProjectsTask
      Condition=" '$(DisableWarnForInvalidRestoreProjects)' != 'true' AND '$(HideWarningsAndErrors)' != 'true' "
      AllProjects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)"
      ValidProjects="@(FilteredRestoreGraphProjectInputItems)" />
  </Target>

  <!--
    ============================================================
    _GenerateRestoreGraph
    Entry point for creating the project to project restore graph.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraph"
        DependsOnTargets="_FilterRestoreGraphProjectInputItems;_GetAllRestoreProjectPathItems"
        Returns="@(_RestoreGraphEntry)">
    <Message Text="Generating dg file" Importance="low" />
    <Message Text="%(_RestoreProjectPathItems.Identity)" Importance="low" />

    <!-- Use all projects if RestoreRecursive is true. Otherwise use only the top level projects. -->
    <ItemGroup>
      <_GenerateRestoreGraphProjectEntryInput Include="@(FilteredRestoreGraphProjectInputItems)" Condition=" '$(RestoreRecursive)' != 'true' " />
      <_GenerateRestoreGraphProjectEntryInput Include="@(_RestoreProjectPathItems)" Condition=" '$(RestoreRecursive)' == 'true' " />
    </ItemGroup>

    <!-- Add top level entries to the direct restore list. These projects will also restore tools. -->
    <MSBuild
        BuildInParallel="$(RestoreBuildInParallel)"
        Projects="@(_GenerateRestoreGraphProjectEntryInput)"
        Targets="_GenerateRestoreGraphProjectEntry"
        Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreGraphEntry" />
    </MSBuild>

    <!-- Generate a spec for every project including dependencies. -->
    <MSBuild
        BuildInParallel="$(RestoreBuildInParallel)"
        Projects="@(_RestoreProjectPathItems)"
        Targets="_GenerateProjectRestoreGraph"
        Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreGraphProjectEntry
    Top level entry point within a project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraphProjectEntry"
          DependsOnTargets="_GenerateRestoreSpecs;_GenerateDotnetCliToolReferenceSpecs"
          Returns="@(_RestoreGraphEntry)">
    <!-- Returns restore graph entries for the project and all dependencies -->
  </Target>

  <!--
    ============================================================
    _GenerateRestoreSpecs
    Mark entry points for restore.
    ============================================================
  -->
  <Target Name="_GenerateRestoreSpecs"
      DependsOnTargets="_GetRestoreProjectStyle"
      Returns="@(_RestoreGraphEntry)">
    <Message Text="Restore entry point $(MSBuildProjectFullPath)" Importance="low" />

    <!-- Mark entry point -->
    <ItemGroup Condition=" '$(RestoreProjects)' == '' OR '$(RestoreProjects)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())" Condition=" '$(RestoreProjectStyle)' != 'Unknown' ">
        <Type>RestoreSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GenerateDotnetCliToolReferenceSpecs
    Collect DotnetCliToolReferences
    ============================================================
  -->
  <Target Name="_GenerateDotnetCliToolReferenceSpecs"
      DependsOnTargets="_GetRestoreSettings"
      Returns="@(_RestoreGraphEntry)">

    <PropertyGroup>
      <DotnetCliToolTargetFramework Condition=" '$(DotnetCliToolTargetFramework)' == '' ">netcoreapp1.0</DotnetCliToolTargetFramework>
    </PropertyGroup>

    <!-- Write out tool references -->
    <GetRestoreDotnetCliToolsTask
      Condition=" '$(RestoreDotnetCliToolReferences)' == '' OR '$(RestoreDotnetCliToolReferences)' == 'true' "
      ProjectPath="$(MSBuildProjectFullPath)"
      ToolFramework="$(DotnetCliToolTargetFramework)"
      RestorePackagesPath="$(_OutputPackagesPath)"
      RestoreFallbackFolders="$(_OutputFallbackFolders)"
      RestoreSources="$(_OutputSources)"
      RestoreConfigFilePaths="$(_OutputConfigFilePaths)"
      DotnetCliToolReferences="@(DotnetCliToolReference)">

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetRestoreDotnetCliToolsTask>

  </Target>

  <!--
    ============================================================
    _GetProjectJsonPath
    Discover the project.json path if one exists for the project.
    ============================================================
  -->
  <Target Name="_GetProjectJsonPath"
    Returns="$(_CurrentProjectJsonPath)">
    <!-- Get project.json path -->
    <!-- Skip this if the project style is already set. -->
    <GetRestoreProjectJsonPathTask
      ProjectPath="$(MSBuildProjectFullPath)"
      Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == '' ">
      <Output TaskParameter="ProjectJsonPath" PropertyName="_CurrentProjectJsonPath" />
    </GetRestoreProjectJsonPathTask>
  </Target>

  <!--
    ============================================================
    _GetRestoreProjectStyle
    Determine the project restore type.
    ============================================================
  -->
  <Target Name="_GetRestoreProjectStyle"
    DependsOnTargets="_GetProjectJsonPath;CollectPackageReferences"
    Returns="$(RestoreProjectStyle);$(PackageReferenceCompatibleProjectStyle)">

    <!--
      Older versions of MSBuild do not support the Count() item function which is an optimization.  Expanding the
      entire item list into a semicolon delimited string is slower but older versions of MSBuild don't support it so
      use the older logic if necessary
    -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &lt; '15.0'">
      <_HasPackageReferenceItems Condition="'@(PackageReference)' != ''">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &gt;= '15.0'">
      <_HasPackageReferenceItems Condition="@(PackageReference->Count()) > 0">true</_HasPackageReferenceItems>
    </PropertyGroup>

    <GetRestoreProjectStyleTask
      HasPackageReferenceItems="$(_HasPackageReferenceItems)"
      MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
      MSBuildProjectName="$(MSBuildProjectName)"
      ProjectJsonPath="$(_CurrentProjectJsonPath)"
      RestoreProjectStyle="$(RestoreProjectStyle)">
      <Output TaskParameter="ProjectStyle" PropertyName="RestoreProjectStyle" />
      <Output TaskParameter="IsPackageReferenceCompatibleProjectStyle" PropertyName="PackageReferenceCompatibleProjectStyle" />
    </GetRestoreProjectStyleTask>

    <PropertyGroup>
      <_HasPackageReferenceItems />
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    EnableIntermediateOutputPathMismatchWarning
    If using PackageReference, enable an MSBuild warning if BaseIntermediateOutputPath is set to something different
    than MSBuildProjectExtensionsPath, because it may be unexpected that the assets and related files wouldn't be written
    to the BaseIntermediateOutputPath.
    ============================================================
  -->

  <Target Name="EnableIntermediateOutputPathMismatchWarning" DependsOnTargets="_GetRestoreProjectStyle"
          BeforeTargets="_CheckForInvalidConfigurationAndPlatform"
          Condition="'$(RestoreProjectStyle)' == 'PackageReference'">

    <PropertyGroup Condition="'$(EnableBaseIntermediateOutputPathMismatchWarning)' == ''">
      <EnableBaseIntermediateOutputPathMismatchWarning>true</EnableBaseIntermediateOutputPathMismatchWarning>
    </PropertyGroup>

  </Target>

  <!--
    ============================================================
    _GetRestoreTargetFrameworksOutput
    Read target frameworks from the project.
    Non-NETCore project frameworks will be returned.
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksOutput"
    DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride"
    Returns="@(_RestoreTargetFrameworksOutputFiltered)">

    <PropertyGroup>
      <_RestoreProjectFramework/>
      <_TargetFrameworkToBeUsed Condition=" '$(_TargetFrameworkOverride)' == '' ">$(TargetFrameworks)</_TargetFrameworkToBeUsed>
    </PropertyGroup>

    <!-- For project.json projects target frameworks will be read from project.json. -->
    <GetProjectTargetFrameworksTask
      Condition=" '$(RestoreProjectStyle)' != 'ProjectJson'"
      ProjectPath="$(MSBuildProjectFullPath)"
      TargetFrameworks="$(_TargetFrameworkToBeUsed)"
      TargetFramework="$(TargetFramework)"
      TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
      TargetPlatformVersion="$(TargetPlatformVersion)"
      TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output
        TaskParameter="ProjectTargetFrameworks"
        PropertyName="_RestoreProjectFramework" />
    </GetProjectTargetFrameworksTask>

    <ItemGroup Condition=" '$(_RestoreProjectFramework)' != '' ">
      <_RestoreTargetFrameworksOutputFiltered Include="$(_RestoreProjectFramework.Split(';'))" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreTargetFrameworksAsItems
    Read $(TargetFrameworks) from the project as items.
    Projects that do not have $(TargetFrameworks) will noop.
    If $(TargetFramework) is specified globally, it'll be preferred over $(TargetFrameworks)
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksAsItems"
    DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride"
    Returns="@(_RestoreTargetFrameworkItems)">
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' == '' ">
      <_RestoreTargetFrameworkItems Include="$(TargetFrameworks.Split(';'))" />
    </ItemGroup>
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' != '' ">
      <_RestoreTargetFrameworkItems Include="$(_TargetFrameworkOverride)" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreSettings
    ============================================================
  -->
  <Target Name="_GetRestoreSettings"
          Condition=" '$(RestoreProjectStyle)' == 'PackageReference' OR '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == 'DotnetToolReference' OR '$(RestoreProjectStyle)' == 'PackagesConfig'"
          DependsOnTargets="_GetRestoreSettingsOverrides;_GetRestoreSettingsCurrentProject;_GetRestoreSettingsAllFrameworks"
          Returns="$(_OutputSources);$(_OutputPackagesPath);$(_OutputRepositoryPath);$(_OutputFallbackFolders);$(_OutputConfigFilePaths)">

    <PropertyGroup Condition=" '$(RestoreSolutionDirectory)' == '' AND '$(RestoreProjectStyle)' == 'PackagesConfig' AND '$(SolutionDir)' != '*Undefined*'">
      <RestoreSolutionDirectory>$(SolutionDir)</RestoreSolutionDirectory>
    </PropertyGroup>
    <!-- For transitive project styles, we rely on evaluating all the settings and including them in the dg spec to faciliate no-op restore-->
    <GetRestoreSettingsTask
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      RestoreSources="$(RestoreSources)"
      RestorePackagesPath="$(RestorePackagesPath)"
      RestoreRepositoryPath="$(RestoreRepositoryPath)"
      RestoreFallbackFolders="$(RestoreFallbackFolders)"
      RestoreConfigFile="$(RestoreConfigFile)"
      RestoreRootConfigDirectory="$(RestoreRootConfigDirectory)"
      RestoreSolutionDirectory="$(RestoreSolutionDirectory)"
      RestoreSettingsPerFramework="@(_RestoreSettingsPerFramework)"
      RestorePackagesPathOverride="$(_RestorePackagesPathOverride)"
      RestoreRepositoryPathOverride="$(_RestoreRepositoryPathOverride)"
      RestoreSourcesOverride="$(_RestoreSourcesOverride)"
      RestoreFallbackFoldersOverride="$(_RestoreFallbackFoldersOverride)"
      RestoreProjectStyle="$(RestoreProjectStyle)"
      MSBuildStartupDirectory="$(MSBuildStartupDirectory)">
      <Output
        TaskParameter="OutputSources"
        PropertyName="_OutputSources" />
      <Output
        TaskParameter="OutputPackagesPath"
        PropertyName="_OutputPackagesPath" />
      <Output
        TaskParameter="OutputRepositoryPath"
        PropertyName="_OutputRepositoryPath" />
      <Output
        TaskParameter="OutputFallbackFolders"
        PropertyName="_OutputFallbackFolders" />
      <Output
        TaskParameter="OutputConfigFilePaths"
        PropertyName="_OutputConfigFilePaths" />
    </GetRestoreSettingsTask>
  </Target>

  <!--
    ============================================================
    _GetRestoreSettingsCurrentProject
    Generate items for a single framework.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsCurrentProject"
    Condition=" '$(TargetFrameworks)' == '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' "
    DependsOnTargets="_GetRestoreSettingsPerFramework"
    Returns="@(_RestoreSettingsPerFramework)">
  </Target>

  <!--
    ============================================================
    _GetRestoreSettingsAllFrameworks
    Generate items for all frameworks.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsAllFrameworks"
    Condition=" '$(TargetFrameworks)' != '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' "
    DependsOnTargets="_GetRestoreTargetFrameworksAsItems;_GetRestoreProjectStyle"
    Returns="@(_RestoreSettingsPerFramework)">

    <!-- Read additional sources and fallback folders for each framework  -->
    <MSBuild
      BuildInParallel="$(RestoreBuildInParallel)"
      Projects="$(MSBuildProjectFullPath)"
      Targets="_GetRestoreSettingsPerFramework"
      Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);
                  $(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreSettingsPerFramework" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GetRestoreSettingsPerFramework
    Generate items with framework specific settings.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsPerFramework"
    Returns="@(_RestoreSettingsPerFramework)">

    <ItemGroup>
      <_RestoreSettingsPerFramework Include="$([System.Guid]::NewGuid())">
        <RestoreAdditionalProjectSources>$(RestoreAdditionalProjectSources)</RestoreAdditionalProjectSources>
        <RestoreAdditionalProjectFallbackFolders>$(RestoreAdditionalProjectFallbackFolders)</RestoreAdditionalProjectFallbackFolders>
        <RestoreAdditionalProjectFallbackFoldersExcludes>$(RestoreAdditionalProjectFallbackFoldersExcludes)</RestoreAdditionalProjectFallbackFoldersExcludes>
      </_RestoreSettingsPerFramework>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectSpec
    Generate a restore project spec for the current project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectSpec"
    DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworksOutput;_GetRestoreSettings"
    Returns="@(_RestoreGraphEntry)">

    <!-- Determine the restore output path -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <RestoreOutputPath Condition=" '$(RestoreOutputPath)' == '' ">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    </PropertyGroup>

    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)" Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson'">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>

    <!--
      Determine project name for the assets file.
      Highest priority: PackageId
      If PackageId does not exist use: AssemblyName
      If AssemblyName does not exist fallback to the project file name without the extension: $(MSBuildProjectName)

      For non-PackageReference projects use only: $(MSBuildProjectName)
    -->
    <PropertyGroup>
      <_RestoreProjectName>$(MSBuildProjectName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(AssemblyName)' != '' ">$(AssemblyName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(PackageId)' != '' ">$(PackageId)</_RestoreProjectName>
    </PropertyGroup>

    <!--
      Determine project version for .NETCore projects
      Default to 1.0.0
      Use Version if it exists
      Override with PackageVersion if it exists (same as pack)
    -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreProjectVersion>1.0.0</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(Version)' != '' ">$(Version)</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(PackageVersion)' != '' ">$(PackageVersion)</_RestoreProjectVersion>
    </PropertyGroup>

    <!-- Determine if this will use cross targeting -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(TargetFrameworks)' != '' ">
      <_RestoreCrossTargeting>true</_RestoreCrossTargeting>
    </PropertyGroup>

    <!-- Determine if ContentFiles should be written by NuGet -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_RestoreSkipContentFileWrite)' == '' ">
      <_RestoreSkipContentFileWrite Condition=" '$(TargetFrameworks)' == '' AND '$(TargetFramework)' == '' ">true</_RestoreSkipContentFileWrite>
    </PropertyGroup>

    <!-- Write properties for the top level entry point -->
    <ItemGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <Version>$(_RestoreProjectVersion)</Version>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <RuntimeIdentifiers>$(RuntimeIdentifiers);$(RuntimeIdentifier)</RuntimeIdentifiers>
        <RuntimeSupports>$(RuntimeSupports)</RuntimeSupports>
        <CrossTargeting>$(_RestoreCrossTargeting)</CrossTargeting>
        <RestoreLegacyPackagesDirectory>$(RestoreLegacyPackagesDirectory)</RestoreLegacyPackagesDirectory>
        <ValidateRuntimeAssets>$(ValidateRuntimeIdentifierCompatibility)</ValidateRuntimeAssets>
        <SkipContentFileWrite>$(_RestoreSkipContentFileWrite)</SkipContentFileWrite>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <WarningsAsErrors>$(WarningsAsErrors)</WarningsAsErrors>
        <NoWarn>$(NoWarn)</NoWarn>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <_CentralPackageVersionsEnabled>$(_CentralPackageVersionsEnabled)</_CentralPackageVersionsEnabled>
        <CentralPackageVersionOverrideEnabled>$(CentralPackageVersionOverrideEnabled)</CentralPackageVersionOverrideEnabled>
        <CentralPackageTransitivePinningEnabled>$(CentralPackageTransitivePinningEnabled)</CentralPackageTransitivePinningEnabled>
      </_RestoreGraphEntry>
    </ItemGroup>

    <!-- Use project.json -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectJsonPath>$(_CurrentProjectJsonPath)</ProjectJsonPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
      </_RestoreGraphEntry>
    </ItemGroup>

    <!-- Use packages.config -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'PackagesConfig' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config')">$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config</PackagesConfigPath>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.config')">$(MSBuildProjectDirectory)\packages.config</PackagesConfigPath>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <Sources>$(_OutputSources)</Sources>
        <SolutionDir>$(SolutionDir)</SolutionDir>
        <RepositoryPath>$(_OutputRepositoryPath)</RepositoryPath>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
      </_RestoreGraphEntry>
    </ItemGroup>

    <!-- Non-NuGet type -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'Unknown' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GenerateProjectRestoreGraph
    Recursively walk project to project references.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraph"
      DependsOnTargets="
      _GetRestoreProjectStyle;
      _GenerateRestoreProjectSpec;
      _GenerateRestoreDependencies"
      Returns="@(_RestoreGraphEntry)">

    <!-- Output from dependency targets -->
  </Target>

  <!--
    ============================================================
    _GenerateRestoreDependencies
    Generate items for package and project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreDependencies"
    DependsOnTargets="_GenerateProjectRestoreGraphAllFrameworks;_GenerateProjectRestoreGraphCurrentProject"
    Returns="@(_RestoreGraphEntry)">
  </Target>

  <!--
    ============================================================
    _GenerateProjectRestoreGraphAllFrameworks
    Walk dependencies for all frameworks.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphAllFrameworks"
      Condition=" '$(TargetFrameworks)' != '' "
      DependsOnTargets="_GetRestoreTargetFrameworksAsItems"
      Returns="@(_RestoreGraphEntry)">

    <!-- Get project and package references  -->
    <!-- Evaluate for each framework -->
    <MSBuild
      BuildInParallel="$(RestoreBuildInParallel)"
      Projects="$(MSBuildProjectFullPath)"
      Targets="_GenerateProjectRestoreGraphPerFramework"
      Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);
                  $(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GenerateProjectRestoreGraphCurrentProject
    Walk dependencies with the current framework.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphCurrentProject"
    Condition=" '$(TargetFrameworks)' == '' "
    DependsOnTargets="_GenerateProjectRestoreGraphPerFramework"
    Returns="@(_RestoreGraphEntry)">
  </Target>

  <!--
    ============================================================
    _GenerateProjectRestoreGraphPerFramework
    Walk dependencies using $(TargetFramework)
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphPerFramework"
    DependsOnTargets="_GetRestoreProjectStyle;CollectPackageReferences;CollectPackageDownloads;CollectFrameworkReferences;CollectCentralPackageVersions"
    Returns="@(_RestoreGraphEntry)">

    <!-- Write out project references -->
    <GetRestoreProjectReferencesTask
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      ProjectReferences="@(ProjectReference)"
      TargetFrameworks="$(TargetFramework)"
      ParentProjectPath="$(MSBuildProjectFullPath)">

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetRestoreProjectReferencesTask>

    <!-- Write out package references-->
    <GetRestorePackageReferencesTask
      Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' "
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      PackageReferences="@(PackageReference)"
      TargetFrameworks="$(TargetFramework)"
      >

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetRestorePackageReferencesTask>

    <!-- Write out central package versions -->
    <GetCentralPackageVersionsTask
      Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_CentralPackageVersionsEnabled)' == 'true' "
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      CentralPackageVersions="@(PackageVersion)"
      TargetFrameworks="$(TargetFramework)"
      >

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetCentralPackageVersionsTask>

    <!-- Write out package downloads -->
    <GetRestorePackageDownloadsTask
      Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' "
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      PackageDownloads="@(PackageDownload)"
      TargetFrameworks="$(TargetFramework)"
      >

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetRestorePackageDownloadsTask>

    <!-- Write out Framework References-->
    <GetRestoreFrameworkReferencesTask
      Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' "
      ProjectUniqueName="$(MSBuildProjectFullPath)"
      FrameworkReferences="@(FrameworkReference)"
      TargetFrameworks="$(TargetFramework)"
      >

      <Output
        TaskParameter="RestoreGraphItems"
        ItemName="_RestoreGraphEntry" />
    </GetRestoreFrameworkReferencesTask>

    <!-- Write out target framework information -->
    <ItemGroup Condition="  '$(PackageReferenceCompatibleProjectStyle)' == 'true'">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>TargetFrameworkInformation</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <PackageTargetFallback>$(PackageTargetFallback)</PackageTargetFallback>
        <AssetTargetFallback>$(AssetTargetFallback)</AssetTargetFallback>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
        <TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
        <TargetFrameworkProfile>$(TargetFrameworkProfile)</TargetFrameworkProfile>
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <CLRSupport>$(CLRSupport)</CLRSupport>
        <RuntimeIdentifierGraphPath>$(RuntimeIdentifierGraphPath)</RuntimeIdentifierGraphPath>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsCurrentProject
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsCurrentProject"
    Condition=" '$(TargetFrameworks)' == '' "
    DependsOnTargets="_GenerateRestoreProjectPathItemsPerFramework"
    Returns="@(_RestoreProjectPathItems)">
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsPerFramework
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsPerFramework"
    Returns="@(_RestoreProjectPathItems)">

    <!-- Get the absolute paths to all projects -->
    <ConvertToAbsolutePath Paths="@(ProjectReference)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_RestoreGraphAbsoluteProjectPaths" />
    </ConvertToAbsolutePath>

    <ItemGroup>
      <_RestoreProjectPathItems Include="$(_RestoreGraphAbsoluteProjectPaths)" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectPathItems
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItems"
    DependsOnTargets="_GenerateRestoreProjectPathItemsAllFrameworks;_GenerateRestoreProjectPathItemsCurrentProject"
    Returns="@(_CurrentRestoreProjectPathItems)">

    <!-- Drop any duplicate items -->
    <RemoveDuplicates
      Inputs="@(_RestoreProjectPathItems)">
      <Output
          TaskParameter="Filtered"
          ItemName="_CurrentRestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsAllFrameworks
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsAllFrameworks"
    Condition=" '$(TargetFrameworks)' != '' "
    DependsOnTargets="_GetRestoreTargetFrameworksAsItems"
    Returns="@(_RestoreProjectPathItems)">

    <!-- Get all project references for the current project  -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' "
      BuildInParallel="$(RestoreBuildInParallel)"
      Projects="$(MSBuildProjectFullPath)"
      Targets="_GenerateRestoreProjectPathItemsPerFramework"
      SkipNonexistentTargets="true"
      SkipNonexistentProjects="true"
      Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);
                  $(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItems" />
    </MSBuild>

    <!-- Without SkipNonexistentTargets support -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' "
      Projects="$(MSBuildProjectFullPath)"
      Targets="_GenerateRestoreProjectPathItemsPerFramework"
      ContinueOnError="$(RestoreContinueOnError)"
      Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);
                  $(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GenerateRestoreProjectPathWalk
    Recursively walk projects
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathWalk"
    DependsOnTargets="_GenerateRestoreProjectPathItems"
    Returns="@(_RestoreProjectPathItems)">

    <!-- Walk project references  -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' "
      BuildInParallel="$(RestoreBuildInParallel)"
      Projects="@(_CurrentRestoreProjectPathItems)"
      Targets="_GenerateRestoreProjectPathWalk"
      SkipNonexistentTargets="true"
      SkipNonexistentProjects="true"
      Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>

    <!-- Without SkipNonexistentTargets -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' "
      Projects="@(_CurrentRestoreProjectPathItems)"
      Targets="_GenerateRestoreProjectPathWalk"
      ContinueOnError="$(RestoreContinueOnError)"
      Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>

    <!-- Include the current project in the result -->
    <ItemGroup>
      <_GenerateRestoreProjectPathWalkOutputs Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>

    <!-- Remove duplicates -->
    <RemoveDuplicates
      Inputs="@(_GenerateRestoreProjectPathWalkOutputs)">
      <Output
          TaskParameter="Filtered"
          ItemName="_RestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>

  <!--
    ============================================================
    _GetAllRestoreProjectPathItems
    Get the full list of known projects.
    This includes all child projects from all target frameworks.
    ============================================================
  -->
  <Target Name="_GetAllRestoreProjectPathItems"
          DependsOnTargets="_FilterRestoreGraphProjectInputItems"
          Returns="@(_RestoreProjectPathItems)">

    <NuGetMessageTask Name="DeterminingProjectsToRestore" Importance="High" />

    <!-- Walk projects -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild
        Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' "
        BuildInParallel="$(RestoreBuildInParallel)"
        Projects="@(FilteredRestoreGraphProjectInputItems)"
        Targets="_GenerateRestoreProjectPathWalk"
        SkipNonexistentTargets="true"
        SkipNonexistentProjects="true"
        Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>

    <!-- Without SkipNonexistentTargets -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' "
      Projects="@(FilteredRestoreGraphProjectInputItems)"
      Targets="_GenerateRestoreProjectPathWalk"
      ContinueOnError="$(RestoreContinueOnError)"
      Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>

    <!-- Remove duplicates -->
    <RemoveDuplicates
      Inputs="@(_RestoreProjectPathItemsOutputs)">
      <Output
          TaskParameter="Filtered"
          ItemName="_RestoreProjectPathItemsWithoutDupes" />
    </RemoveDuplicates>

    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild
        Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' "
        BuildInParallel="$(RestoreBuildInParallel)"
        Projects="@(_RestoreProjectPathItemsWithoutDupes)"
        Targets="_IsProjectRestoreSupported"
        SkipNonexistentTargets="true"
        SkipNonexistentProjects="true"
        Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItems" />
    </MSBuild>

    <!-- Without SkipNonexistentTargets -->
    <MSBuild
      Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' "
      Projects="@(_RestoreProjectPathItemsWithoutDupes)"
      Targets="_IsProjectRestoreSupported"
      ContinueOnError="$(RestoreContinueOnError)"
      Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GetRestoreSettingsOverrides
    Get global property overrides that should be resolved
    against the current working directory instead of the project.
    This is done by calling into NuGet.targets in a new scope,
    project properties will not be returned by the calls below.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsOverrides"
          Returns="$(_RestorePackagesPathOverride);$(_RestoreRepositoryPathOverride);$(_RestoreSourcesOverride);$(_RestoreFallbackFoldersOverride)">

    <!-- RestorePackagesPathOverride -->
    <MSBuild
        BuildInParallel="$(RestoreBuildInParallel)"
        Condition=" '$(RestorePackagesPath)' != '' "
        Projects="$(MSBuildThisFileFullPath)"
        Targets="_GetRestorePackagesPathOverride">

      <Output
          TaskParameter="TargetOutputs"
          PropertyName="_RestorePackagesPathOverride" />
    </MSBuild>

    <!-- RestoreRepositoryPathOverride -->
    <MSBuild
      BuildInParallel="$(RestoreBuildInParallel)"
      Condition=" '$(RestoreRepositoryPathOverride)' != '' "
      Projects="$(MSBuildThisFileFullPath)"
      Targets="_GetRestoreRepositoryPathOverride">

      <Output
        TaskParameter="TargetOutputs"
        PropertyName="_RestoreRepositoryPathOverride" />
    </MSBuild>

    <!-- RestoreSourcesOverride -->
    <MSBuild
        BuildInParallel="$(RestoreBuildInParallel)"
        Condition=" '$(RestoreSources)' != '' "
        Projects="$(MSBuildThisFileFullPath)"
        Targets="_GetRestoreSourcesOverride">

      <Output
          TaskParameter="TargetOutputs"
          PropertyName="_RestoreSourcesOverride" />
    </MSBuild>

    <!-- RestoreFallbackFoldersOverride -->
    <MSBuild
        BuildInParallel="$(RestoreBuildInParallel)"
        Condition=" '$(RestoreFallbackFolders)' != '' "
        Projects="$(MSBuildThisFileFullPath)"
        Targets="_GetRestoreFallbackFoldersOverride">

      <Output
          TaskParameter="TargetOutputs"
          PropertyName="_RestoreFallbackFoldersOverride" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GetRestorePackagesPathOverride
    ============================================================
  -->
  <Target Name="_GetRestorePackagesPathOverride"
          Returns="$(_RestorePackagesPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestorePackagesPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreRepositoryPathOverride
    ============================================================
  -->
  <Target Name="_GetRestoreRepositoryPathOverride"
          Returns="$(_RestoreRepositoryPathOverride)">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestoreRepositoryPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreSourcesOverride
    ============================================================
  -->
  <Target Name="_GetRestoreSourcesOverride"
          Returns="$(_RestoreSourcesOverride)">
    <PropertyGroup>
      <_RestoreSourcesOverride>$(RestoreSources)</_RestoreSourcesOverride>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreFallbackFoldersOverride
    ============================================================
  -->
  <Target Name="_GetRestoreFallbackFoldersOverride"
          Returns="$(_RestoreFallbackFoldersOverride)">
    <PropertyGroup>
      <_RestoreFallbackFoldersOverride>$(RestoreFallbackFolders)</_RestoreFallbackFoldersOverride>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _GetRestoreTargetFrameworkOverride
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworkOverride"
          Condition=" '$(_DisableNuGetRestoreTargetFrameworksOverride)' != 'true' "
          Returns="$(_TargetFrameworkOverride)">

    <GetGlobalPropertyValueTask
      PropertyName="TargetFramework"
        Condition=" '$(TargetFrameworks)' != '' ">
      <Output TaskParameter="GlobalPropertyValue" PropertyName="_TargetFrameworkOverride" />
    </GetGlobalPropertyValueTask>

    <!-- Only set the override if TargetFrameworks has not been overriden as well. In that case, prefer it. -->
  </Target>

  <!--
    ============================================================
    _GetTargetFrameworkOverrides
    ============================================================
  -->
  <Target Name="_GetTargetFrameworkOverrides"
          Returns="$(_TargetFrameworkOverride)">
    <PropertyGroup>
      <_TargetFrameworkOverride Condition=" '$(TargetFrameworks)' == '' ">$(TargetFramework)</_TargetFrameworkOverride>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _IsProjectRestoreSupported
    Verify restore targets exist in the project.
    ============================================================
  -->
  <Target Name="_IsProjectRestoreSupported"
          Returns="@(_ValidProjectsForRestore)">

    <ItemGroup>
      <_ValidProjectsForRestore Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
  </Target>

  <!--
    ============================================================
    Import NuGet.RestoreEx.targets if the MSBuild property 'RestoreEnableStaticGraph'
    is 'true'.  This file overrides the Restore target to use MSBuild Static Graph
    to load and evaluate projects which is much faster.

    This feature is not supported for NuGet.exe scenarios and NuGet.RestoreEx.targets
    won't exist in that case.
    ============================================================
  -->
  <Import Project="NuGet.RestoreEx.targets" Condition="'$(RestoreUseStaticGraphEvaluation)' == 'true' And Exists('NuGet.RestoreEx.targets')" />

</Project>
